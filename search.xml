<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>install fluxcd in k8s 1.25.5</title>
      <link href="//post/install-fluxcd-in-k8s-1-25-5.html"/>
      <url>//post/install-fluxcd-in-k8s-1-25-5.html</url>
      
        <content type="html"><![CDATA[<p>以下是在Kubernetes上使用Flux CD进行GitOps的步骤：</p><p>1.安装Flux CLI：使用<code>brew install fluxcd/tap/flux</code>命令进行安装。</p><p>2.显示Flux CLI版本：使用<code>flux version</code>命令显示Flux CLI版本信息。</p><p>3.在GitHub上创建Git仓库。</p><p>4.设置GITHUB_TOKEN环境变量。</p><p>5.使用<code>flux bootstrap github</code>命令将Flux CD安装到Kubernetes集群中。在命令中，需要指定GitHub用户名和仓库名、读写密钥、分支以及使用的组件（包括image-reflector-controller和image-automation-controller）。</p><p>6.等待Flux CD Pod启动并完成初始化。</p><p>请注意，只有在使用<code>--components-extra=image-reflector-controller,image-automation-controller</code>参数时，才能创建与镜像相关的Pod。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql error: rec.cc:391 thread </title>
      <link href="//post/mysql-error-rec-cc-391-thread.html"/>
      <url>//post/mysql-error-rec-cc-391-thread.html</url>
      
        <content type="html"><![CDATA[<p>此错误仅在 MySQL 8.0.30 版本中存在。请参见 <a href="https://bugs.mysql.com/bug.php?id=107941">https://bugs.mysql.com/bug.php?id=107941</a> bug 报告。升级 MySQL 版本到 8.0.31 可以解决此错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何清理 Kubernetes namespace 中的 finalizers 并成功删除 argocd namespace</title>
      <link href="//post/ru-he-qing-li-kubernetes-namespace-zhong-de-finalizers-bing-cheng-gong-shan-chu-argocd-namespace.html"/>
      <url>//post/ru-he-qing-li-kubernetes-namespace-zhong-de-finalizers-bing-cheng-gong-shan-chu-argocd-namespace.html</url>
      
        <content type="html"><![CDATA[<p>在删除 Kubernetes 集群中的资源时，我遵循以下步骤：</p><ol><li>删除所有 <code>deploy</code>。</li><li>删除所有 <code>configmap</code>。</li><li>删除所有 <code>namespace</code>。</li></ol><p>&amp;nbsp;&amp;nbsp;然而，我发现在删除 <code>namespace</code> 时出现了问题。尝试了官方提供的命令<br><code>kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</code><br>但是 <code>namespace</code> 删除仍然被卡住了。我注意到该 <code>namespace</code> 下存在多个 <code>argoproj.io/v1alpha1/applications</code> 资源，并且所有资源都包含一个 <code>finalizers</code> 字段。通过搜索引擎，我了解到只有删除所有资源 YAML 文件中的 <code>finalizers</code> 字段才能解决 <code>namespace</code> 删除被卡住的问题。因此，我直接删除了 <code>finalizers</code> 字段并更新了所有资源，直到所有资源都被修改好为止。最终，<code>namespace</code> 能够被成功删除。<br>&amp;nbsp;&amp;nbsp;在 Kubernetes 中，删除某些资源时，这些资源可能具有关联的其他资源，这些关联资源需要被清理，以便能够顺利删除要删除的资源。当某个 <code>namespace</code> 中存在关联资源时，删除该 <code>namespace</code> 可能会失败。在这种情况下，Kubernetes 会在 <code>namespace</code> 对应的 <code>finalizers</code> 列表中添加一些条目，以确保所有关联资源被清理，然后再删除 <code>namespace</code>。在删除 <code>namespace</code> 时，Kubernetes 会检查 <code>finalizers</code> 列表中的所有条目，确保这些条目对应的所有资源已被清理，然后才会继续删除 <code>namespace</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helm 报错：another operation (install/upgrade/rollback) is in progress处理方法</title>
      <link href="//post/helm-bao-cuo-another-operation-install-upgrade-rollback-is-in-progress-chu-li-fang-fa.html"/>
      <url>//post/helm-bao-cuo-another-operation-install-upgrade-rollback-is-in-progress-chu-li-fang-fa.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文介绍使用Flux CD管理Helm Releases的方法。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在使用Helm Release时，有时会出现报错信息：”another operation (install/upgrade/rollback) is in progress”。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>运行<code>helm history &lt;name&gt; --namespace &lt;ns&gt;</code>命令，查看Release的历史版本。</p><p><img src="/medias/1675238086770.jpeg" alt="/medias/1675238086770.jpeg"></p></li><li><p>运行<code>lux suspend hr &lt;name&gt; -n &lt;ns&gt;</code>命令，暂停Release的自动升级。</p></li><li><p>选择<code>status=pending-upgrade</code>的版本，运行<code>helm uninstall &lt;name&gt; --namespace &lt;ns&gt; &lt;REVISION&gt;</code>命令，卸载该版本。</p></li><li><p>运行<code>flux resume helmrelease &lt;name&gt; -n &lt;ns&gt;</code>命令，重新启动Release。</p></li></ol><p>以上步骤可解决该错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s PVC自动扩容实践</title>
      <link href="//post/k8s-pvc-zi-dong-kuo-rong-shi-jian.html"/>
      <url>//post/k8s-pvc-zi-dong-kuo-rong-shi-jian.html</url>
      
        <content type="html"><![CDATA[<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h2 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h2><p>此实践依赖于：</p><ol><li>k8s版本 &gt;= 1.24</li><li><a href="https://github.com/topolvm/pvc-autoresizer">pvc-autoresizer</a> 版本 &gt;= 0.5.0</li></ol><h2 id="安装-pvc-autoresizer"><a href="#安装-pvc-autoresizer" class="headerlink" title="安装 pvc-autoresizer"></a>安装 pvc-autoresizer</h2><ol><li>克隆<a href="https://github.com/topolvm/pvc-autoresizer">pvc-autoresizer</a>仓库并检出版本 0.5.0，然后构建并推送Docker镜像：</li></ol><pre class="line-numbers language-none"><code class="language-none">git clone &lt;https://github.com/topolvm/pvc-autoresizer&gt; &amp;&amp; git checkout v0.5.0 &amp;&amp; cd pvc-autoresizer &amp;&amp; docker build -t pvc-autoresizer:0.5.0 . &amp;&amp; docker push pvc-autoresizer:0.5.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>添加pvc-autoresizer的Helm repo:</li></ol><pre class="line-numbers language-none"><code class="language-none">helm repo add pvc-autoresizer &lt;https://topolvm.github.io/pvc-autoresizer/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>准备<code>values.yaml</code>文件，内容如下：</li></ol><pre class="line-numbers language-none"><code class="language-none"># config from &lt;https://github.com/topolvm/pvc-autoresizer/blob/main/charts/pvc-autoresizer/values.yaml&gt;image:  # image.repository -- pvc-autoresizer image repository to use.  repository: perrorone/pvc-autoresizer  # image.tag -- pvc-autoresizer image tag to use.  # @default -- `{{ .Chart.AppVersion }}`  tag:  v0.5.0controller:  # controller.replicas -- Specify the number of replicas of the controller Pod.  replicas: 1  args:    # controller.args.prometheusURL -- Specify Prometheus URL to query volume stats.    # Used as "--prometheus-url" option    prometheusURL: &lt;you_prometheus_url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>安装pvc-autoresizer:</li></ol><pre class="line-numbers language-none"><code class="language-none">helm install --create-namespace --namespace pvc-autoresizer pvc-autoresizer pvc-autoresizer/pvc-autoresizer --values ./values.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>检查是否安装成功:</li></ol><pre class="line-numbers language-none"><code class="language-none">kubectl get pod -n pvc-autoresizer | grep pvc-autoresizer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建StatefulSet以及存储类"><a href="#创建StatefulSet以及存储类" class="headerlink" title="创建StatefulSet以及存储类"></a>创建StatefulSet以及存储类</h2><ol><li>编写<code>stateful-set.yaml</code>文件，内容如下:</li></ol><pre class="line-numbers language-none"><code class="language-none">apiVersion: storage.k8s.io/v1kind: StorageClassmetadata:  name: test-pvc-autoresizer  namespace: staging  annotations:    resize.topolvm.io/enabled: "true" # 必须存在, 才能自动扩容parameters:  type: pd-ssdprovisioner: pd.csi.storage.gke.ioreclaimPolicy: RetainvolumeBindingMode: WaitForFirstConsumerallowVolumeExpansion: true---apiVersion: apps/v1kind: StatefulSetmetadata:  name: test-pvc-autoresizer  namespace: stagingspec:  selector:    matchLabels:      app: test-pvc-autoresizer  serviceName: "test-pvc-autoresizer"  replicas: 1  template:    metadata:      labels:        app: test-pvc-autoresizer    spec:      terminationGracePeriodSeconds: 10      containers:        - name: test-pvc-autoresizer          image: perrorone/go-file:v1.0.0          ports:            - containerPort: 80              name: http          livenessProbe:            httpGet:              path: /health              port: http          readinessProbe:            httpGet:              path: /health              port: http          volumeMounts:            - name: test-pvc-data              mountPath: /data          resources:            requests:              cpu: 200m              memory: 300Mi            limits:              cpu: 500m              memory: 500Mi  volumeClaimTemplates:    - metadata:        name: test-pvc-data        annotations:  # 必须存在, 使得自动创建的 PVC携带以下设置想才能自动扩容            resize.topolvm.io/storage_limit: 8Gi # 最大扩容大小            resize.topolvm.io/threshold: 20%      spec:        accessModes: [ "ReadWriteOnce" ]        storageClassName: "test-pvc-autoresizer"        resources:          requests:            storage: 1Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>部署StatefulSet和存储类:</li></ol><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f ./stateful-set.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>进入pod并查看挂载目录大小，可以看到<code>/data</code>目录只使用了1%的空间</li></ol><pre class="line-numbers language-none"><code class="language-none">df -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>测试自动扩容，写入文件:</li></ol><pre class="line-numbers language-none"><code class="language-none">dd if=/dev/zero of=1G.file bs=50M count=20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><p>检查pvc-autoresizer pod 日志:</p><p><img src="/medias/1666863168702.jpg" alt="/medias/1666863168702.jpg"></p></li><li><p>再次检查pod挂载目录大小, 可以看见挂载目录已经使用了100%:<code>/dev/sdf 975.9M 959.9M 0 100% /data</code></p></li><li><p>等待一段时间后，再次查看挂载目录大小，可以看见已经扩容成功:<code>/dev/sdf 1.9G 960.4M 1007.4M 49% /data</code>😋😋😋😋😋😋</p></li></ol><p><img src="/medias/1666863439959.jpg" alt="/medias/1666863439959.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的一些小知识</title>
      <link href="//post/redis-de-yi-xie-xiao-zhi-shi.html"/>
      <url>//post/redis-de-yi-xie-xiao-zhi-shi.html</url>
      
        <content type="html"><![CDATA[<h3 id="Redis数据类型的使用场景"><a href="#Redis数据类型的使用场景" class="headerlink" title="Redis数据类型的使用场景"></a>Redis数据类型的使用场景</h3><ul><li>String：其value可以储存string以及数字类型，一般用于复杂的技术功能上。</li><li>Hash：其value存放的是结构化的对象，可以方便地操作某个字段，我使用它实现过用户行为数据缓存以及session功能。</li><li>List：类似Python中的list数据类型，我一般使用它做消息队列或者分页功能。</li><li>Set：该数据结构储存的是一系列无序、不重复的数据，还提供差集、交集等功能。我使用它为爬虫去重以及用户阅读过的文章功能。</li><li>Sorted Set：有序集合储存一系列有序、不重复的数据，大多数场景都使用它做一个榜单的功能。</li></ul><h3 id="Redis的一些缺点"><a href="#Redis的一些缺点" class="headerlink" title="Redis的一些缺点"></a>Redis的一些缺点</h3><ul><li>Redis将所有数据放在内存中以便加快访问的速度，但这也造成了Redis容量受到物理内存大小的限制，所以Redis对于一些海量数据场景有些乏力。</li><li>Redis的在线扩容比较麻烦。如果Redis集群数量到达上限时，此时在线扩容是一个十分复杂的问题，大大提高了运维的成本。</li></ul><h3 id="Redis的过期策略以及内存淘汰机制"><a href="#Redis的过期策略以及内存淘汰机制" class="headerlink" title="Redis的过期策略以及内存淘汰机制"></a>Redis的过期策略以及内存淘汰机制</h3><ul><li>Redis采用了定时删除+惰性删除的方式来删除过期的数据。这里的定时删除，Redis并非将所有设置过期时间的key都遍历一遍，如果这样做将会消耗大量的CPU资源。Redis采用了随机抽样，如果被抽到的key过期了就删除。但如果仅仅是这样，那么有可能一些数据永远不会被抽到。这时Redis引入了惰性删除，在访问KEY的时候检查一下是否过期，过期就删除。</li><li>如果Redis仅仅采用上面两种方式来删除数据，那么在极端情况下仍然会有数据不会被删除。Redis还有内存淘汰策略，我最常使用的是allkeys-lru。当Redis内存到达上限时，它从所有key中寻找最近最少使用的KEY删除。</li></ul><h3 id="大量数据插入Redis应该怎么做？"><a href="#大量数据插入Redis应该怎么做？" class="headerlink" title="大量数据插入Redis应该怎么做？"></a>大量数据插入Redis应该怎么做？</h3><p>使用正常模式来插入显然不是一个明智的选择，而使用管道的话某些客户端会被阻塞，导致不能在这期间执行其他的命令。比较好的方案是根据Redis协议生成一个文件，然后使用pipe mode去执行这个文件。参考<a href="https://redis.io/docs/reference/patterns/bulk-loading/">Redis Mass Insertion</a>。</p><h3 id="Redis分区？"><a href="#Redis分区？" class="headerlink" title="Redis分区？"></a>Redis分区？</h3><ul><li>Redis的分区是指将数据分割成多个子集，分别保存到不同的Redis实例中，每一个Redis实例都只保存了KEY的一个子集。</li><li>Redis的分区在涉及多个key操作的时候，多数是不支持的，更别说多key事务操作。对于备份的情况也比较复杂。</li><li>Redis分区有两种类型：<ol><li>按照范围分区，映射一定范围的对象到特定的Redis实例，但这种并不长使用。</li><li>使用hash分区，其工作原理使用了hash表的原理，类似Python dict。</li></ol></li></ul><h3 id="Redis如何做集群？"><a href="#Redis如何做集群？" class="headerlink" title="Redis如何做集群？"></a>Redis如何做集群？</h3><p>推荐使用官方的<a href="https://redis.io/docs/management/scaling/">Redis Cluster</a>，其实现原理是：Redis集群内部有2<strong>14个哈希槽。当需要插入key时，首先对key使用<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81/10168758?fr=aladdin&amp;fromtitle=CRC%E6%A0%A1%E9%AA%8C&amp;fromid=3439037">crc16算法</a>计算出一个数字，在用此数字对2</strong>14取余，该取余结果就是数据存放的哈希槽位置。而Redis集群的节点管理这使用类似哨兵的机制来实现，集群类节点通过相互ping来判断节点是否能够连接。如果过半数节点都连接不上一个节点，则Redis集群就会认定此节点宕机了。该方案确并不能保证数据的强一致性，所以在使用时一定不要将Redis作为一个高可靠性的存储服务使用！</p><h3 id="Redis如何做持久化？"><a href="#Redis如何做持久化？" class="headerlink" title="Redis如何做持久化？"></a>Redis如何做持久化？</h3><p>Redis支持两种持久化方案：</p><ol><li>快照：通过对配置文件的设置，可以使Redis在N秒类M个key被修改时就将内存的数据以快照的方式写入到后缀为’.rdb’文件中。</li><li>AOF: 每一次收到一次写的命令就将此命令追加到后缀为’.aof’文件中，当Redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cast类型转换库—go库推荐</title>
      <link href="//post/cast-lei-xing-zhuan-huan-ku-go-ku-tui-jian.html"/>
      <url>//post/cast-lei-xing-zhuan-huan-ku-go-ku-tui-jian.html</url>
      
        <content type="html"><![CDATA[<p>在 Go 语言中，类型转换是一项经常需要进行的操作，但转换不同类型之间的值却需要引入不同的库，过程相对繁琐。不过，<code>cast</code> 库解决了这个问题，提供了很多种类型转换函数，而且通常只需要引入这一个库即可。</p><p><code>cast</code> 库不仅提供了常见类型之间的转换，例如 int 转换为 string，还提供了更加复杂的类型转换，例如将时间字符串转换为 <code>time.Time</code> 类型。此外，它还提供了两种转换函数，一种仅返回该类型的零值，不会返回错误，另一种则会返回错误，以便开发人员可以根据实际需求选择使用。</p><p>以下是一些常用的 API：</p><ul><li><code>cast.StringToDate</code>: 将常见的时间字符串转换为 <code>time.Time</code> 类型</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.StringToDate("2006-01-02 15:04:05"))// output: 2006-01-02 15:04:05 +0000 UTC &lt;nil&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>cast.ToBoolSlice</code>: 将任意类型的数组转换为 <code>[]bool</code> 类型</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToBoolSlice([]interface{}{1,2,0,true, false}))// output: [true true false true false]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>cast.ToBool</code>: 将任意类型转换为 <code>bool</code> 类型</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToBool(1)) // output:truefmt.Println(cast.ToBool(0)) // output: falsefmt.Println(cast.ToBool("")) // output: falsefmt.Println(cast.ToBool("0")) // output: falsefmt.Println(cast.ToBool("1")) // output: truefmt.Println(cast.ToBool("true")) // output: truefmt.Println(cast.ToBool("false")) // output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cast.ToString</code>: 将任意类型转换成字符串类型</li></ul><pre class="line-numbers language-none"><code class="language-none">cast.ToString("mayonegg")         // "mayonegg"cast.ToString(8)                  // "8"cast.ToString(8.31)               // "8.31"cast.ToString([]byte("one time")) // "one time"cast.ToString(nil)        // "nil"var foo interface{} = "one more time"cast.ToString(foo)                // "one more time"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cast.ToStringMap</code>: 将任意类型的 map 转换成 <code>map[string]interface{}</code></li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToStringMap(map[interface{}]interface{}{    1:2,    "2":3,    true:1,})) // output: map[1:2 2:3 true:1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的 API 可以在其文档中查看：<a href="https://github.com/spf13/cast">https://github.com/spf13/cast</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis sds详解</title>
      <link href="//post/sds-xiang-jie.html"/>
      <url>//post/sds-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是SDS？"><a href="#什么是SDS？" class="headerlink" title="什么是SDS？"></a>什么是SDS？</h3><p>SDS是Redis构建的一种抽象类型，主要用于储存Redis的默认字符串表示、AOF模块中的AOF缓冲区和客户端状态输入缓冲区。</p><h3 id="SDS的优点"><a href="#SDS的优点" class="headerlink" title="SDS的优点"></a>SDS的优点</h3><p>为什么Redis不使用C字符串？我们需要先了解C字符串的缺点：</p><ol><li>C字符串不记录自身长度信息，获取字符串长度必须遍历整个字符串，时间复杂度为O(n)。</li><li>C字符串不记录自身长度，稍有不小心就会造成缓冲区溢出。</li><li>对于Redis这种缓存类型数据库，对于缓存的Value常常会经常更改。但是C字符串每次的增长或是缩小都需要一次内存的重分配操作。</li><li>Redis数据库中缓存的内容不是特定的，有可能会是图片、音频等等文件的二进制数据，但是C字符串中的字符必须符合某种编码，且字符串中不能包含空格，这些限制也导致了Redis不能使用C字符串来作为自身字符串的实现。</li></ol><p>而SDS则将这些缺点都一一杜绝：</p><ol><li>SDS记录了自身的长度信息，使得获取字符串长度的时间复杂度为O(1)。</li><li>SDS使用了预分配空间以及惰性空间释放的算法，解决了频繁分配内存的操作。</li><li>SDS由于保存了自身的长度，也导致了SDS不会像C一样按照’\0’确定字符串的结尾。</li></ol><h3 id="SDS的实现"><a href="#SDS的实现" class="headerlink" title="SDS的实现"></a>SDS的实现</h3><p>Redis使用名为sdshdr的结构体表示SDS值：</p><pre class="line-numbers language-none"><code class="language-none">struct sdshdr{   int len; // 记录buf数组中已使用字节的数量   int free; // 记录buf中未使用字节数量   char buf[]; // 保存字符串的数组}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SDS遵循C字符串以空字符结尾的惯例，以便能够重用C字符串中的函数。这个结尾的空字符串并不会增加len字段的值。例如现在需要使用SDS保存“golang”这个字符串，那么SDS对应的结构体是：</p><p><img src="https://s1.ax1x.com/2022/03/25/qNgzqI.png" alt="https://s1.ax1x.com/2022/03/25/qNgzqI.png)"></p><p>由于SDS记录了自身的长度，所以Redis中获取字符串的长度只需要返回len字段的字段，其时间复杂度为O(1)。而对于C字符串经常发生的缓冲区溢出，SDS的空间分配策略完全杜绝了这种可能性。当Redis需要对SDS字符串修改时，首先会检查SDS的空间是否满足修改所需的空间。如果不满足则将SDS空间扩容至满足该修改空间所需的容量。SDS空间扩容的算法如下：</p><ol><li>如果SDS修改后的长度小于1MB，那么程序将会分配len字段值同样大小的未使用空间。对于上面那个例子，SDS的总占用大小为：6（len）+ 6（free）+ 1（‘\0’）= 13字节的容量。</li><li>如果SDS修改后的长度大于1MB，那么SDS将会为SDS分配1MB的未使用空间。如果一个SDS len值修改后的容量为2MB，那么Redis将会为SDS分配1MB的未使用空间。则此时SDS的总占用大小为：2MB（len）+ 1MB（len）+ 1byte（‘\0’）= 3073 byte容量。</li></ol><p>这种扩容算法，减少了频繁的向系统申请内存的操作。SDS的空间释放并不是实时的，而是惰性释放：Redis认为如果一个SDS的容量到达过N大小，则极有可能在其缩小后也有可能到达N。且惰性释放也减少了下次内存分配的可能。假如现在有一个“golang”字符串存储在Redis中，现在我们需要将“golang”修改为“go”，那么Redis将会对SDS结构体将会是这样的：</p><p><img src="https://s1.ax1x.com/2022/03/25/qN2RTP.png" alt="https://i.imgur.com/1Bx9XnC.png"><br><img src="https://s1.ax1x.com/2022/03/25/qN24fS.png" alt="https://i.imgur.com/1Bx9XnC.png"></p><p>SDS提供了清理内存的API，我们可以在有需要时调用该API以便真正的释放内存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Redis只会使用C字符串作为字面量使用，大多数情况都使用SDS来表示字符串。</li><li>能够使用常数级复杂度获取字符串的长度。</li><li>杜绝了缓冲区溢出。</li><li>减少了字符串所需内存重新分配的次数。以及对于二进制数据安全，且兼容部分C字符串函数。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的channel详解</title>
      <link href="//post/go-de-channel-xiang-jie.html"/>
      <url>//post/go-de-channel-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<p>此篇文章基于<a href="https://studygolang.com/dl/golang/go1.12.1.src.tar.gz">golang 1.12.1</a> 版本源码解析而成，chan源码位于go/src/runtime/chan.go文件中。</p><h2 id="Channel是个什么？"><a href="#Channel是个什么？" class="headerlink" title="Channel是个什么？"></a>Channel是个什么？</h2><p>在源码中，channel实际是一个结构体，其结构如下：</p><pre class="line-numbers language-none"><code class="language-none">type hchan struct {   qcount   uint           // 队列数据中的数据数量   dataqsiz uint           // 循环队列的大小   buf      unsafe.Pointer // 储存数据的元素数组   elemsize uint16   closed   uint32   elemtype *_type // 元素类型   sendx    uint   // 发送次数   recvx    uint   // 接受次数   recvq    waitq  // 当阻塞时，存放接受者的结构体   sendq    waitq  // 当阻塞时，存放发送者者的结构体   // 用于保证数据的并发安全   lock mutex}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>sendx</code>以及<code>recvx</code>是每次读取或者写入都需要将其加一。而<code>recvq</code>、<code>sendq</code>的作用是，当缓冲区已满的情况下，会将读取或是发送channel结构体放入其中。</p><h2 id="Channel的创建"><a href="#Channel的创建" class="headerlink" title="Channel的创建"></a>Channel的创建</h2><p>创建一个chan我们会使用<code>make</code>函数来创建，实际<code>make</code>函数调用了<code>makechan</code>函数创建，该函数签名如下：</p><pre class="line-numbers language-none"><code class="language-none">func makechan(t *chantype, size int) *hchan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>t</code>是chan接收或者发送的数据类型，<code>size</code>则是<code>make</code>函数的第二个参数，指明了chan的缓冲大小，默认为0即无缓冲chan，返回<code>hchan</code>结构体的指针。创建channel时首先会检测<code>t</code>的大小，如果<code>t</code>的大小超过了65536个字节，将会触发错误。当chan传递的数据类型大小符合要求后，将会根据<code>t</code>类型的特征去创建一定容量大小的内存空间，并将此片内存空间复制给<code>buf</code>。值得一提的是，<code>chan</code>包中提供了一个名称为<code>debugChan</code>的变量，该变量默认为<code>false</code>，当它为<code>true</code>时，对chan操作时将会打印一些debug信息，这将会帮助我们快速的发现由于chan发生的BUG。</p><h2 id="向channel中发送数据"><a href="#向channel中发送数据" class="headerlink" title="向channel中发送数据"></a>向channel中发送数据</h2><p>向chan中发送数据由<a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#71">chan.go:142</a> <code>chansend</code>函数实现。该函数首先会检查当前channel等于nil并且是一个有缓冲通道则直接返回，如果是一个无缓存通道则调用<code>proc.gp:284</code> <code>gopark</code>将当前的goroutine设置为waiting状态。随后检测channel时候已经准备好发送数据了，如果已经可以发送数据，则调用chan.go:264 <code>send</code>函数发送数据。<code>send</code>的作用主要是将要发送的数据<code>copy</code>到<code>buf</code>中，如果当前channel是无缓冲的，则调用<code>lock</code>加锁，阻塞当前goroutine。当前数据被接受后，调用<code>goready</code>通知runtime当前goroutine已经准备好再次运行了。如果channel是有缓冲的，则直接返回。</p><h2 id="从channel中接受数据"><a href="#从channel中接受数据" class="headerlink" title="从channel中接受数据"></a>从channel中接受数据</h2><p>接受数据实际跟发送数据流程是一样的，唯一不同的是，当channel是有缓冲的时候，并且channel中没有数据被发送时，则直接将接受chan数据的变量地址存入到<code>sendq</code>结构体中。当有发送数据时发现<code>recvq</code>中有数据时，直接将数据存入到这个结构体中的地址中，而不再会使用<code>buf</code>去<code>copy</code>数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>channel使用<code>copy buf</code>的方式来通信，最后实现以通信的方式来共享内存。当一个goroutine阻塞的时候，系统线程会把它放入到<code>hchan.sendq</code>或者<code>hchan.recvq</code> list中，该list中的<code>sudog</code>类型的结构题就是当前goroutine，而这个<code>sudog</code>结构体中保存着一个变量，该变量保存着channel相关的指针。之前使用chan仅仅只是会使用，而不知其原理，看了其源码，之前不理解的地方也恍然大悟。写这篇文章时是对着源码写的，可能有一些顺序上的矛盾。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python IO多路复用实践</title>
      <link href="//post/io-duo-lu-fu-yong-shi-jian.html"/>
      <url>//post/io-duo-lu-fu-yong-shi-jian.html</url>
      
        <content type="html"><![CDATA[<p>最近几天一直在看tornado源码，发现tornado虽然标榜使用异步模型实现， 但是实际上是使用IO多路复用实现的事件循环。为了加深对IO多路复用的印象，我决定自己实现一个简易的HTTP客户端以比较同步客户端和IO多路复用客户端的性能差别。</p><p>废话少说，现在先来看看同步客户端与IO多路复用客户端最直观的区别。首先使用tornado实现一个简单的服务器：</p><pre class="line-numbers language-none"><code class="language-none"># -*- coding:utf-8 -*-from tornado.web import RequestHandler, Applicationfrom tornado.ioloop import IOLoopimport tornado.genclass TestHandle(RequestHandler):    async def get(self, *args, **kwargs):        await tornado.gen.sleep(1)        self.write("OK")if __name__ == '__main__':    app = Application([('/', TestHandle)])    app.listen(8080)    IOLoop.current().start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们让服务端在处理请求时暂停1秒，以便更方便地观察两种方式实现的客户端区别。接下来先实现同步客户端：</p><pre class="line-numbers language-none"><code class="language-none"># -*- coding:utf-8 -*-import socketimport timeREQUEST_STR = '{method} {path} HTTP/1.0\\r\\n\\r\\n'def block_client(hostname, port, method, path):    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.connect((hostname, port))    sock.send(REQUEST_STR.format(method=method, path=path).encode())    response_body = []    while True:        response_stream = sock.recv(1024)        if not response_stream:            return b"".join(response_body).decode()        response_body.append(response_stream)if __name__ == '__main__':    count = 3    start_time = time.time()    for _ in range(3):        block_client("127.0.0.1", port=8080, method="GET", path="/")    print("{} 请求{}次, 运行时间: {:.1f}秒".format(block_client.__name__, count, time.time() - start_time))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动服务端，开始测试同步客户端请求服务端需要多少时间：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; C:\\Users\\Administrator&gt;python client.pyblock_client 请求3次, 运行时间: 3.0秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不出所料，请求三次由于服务器暂停了1秒，总计使用时间为3秒。接下来实现IO多路复用客户端，来看看IO多路复用的表现：</p><pre class="line-numbers language-none"><code class="language-none">from selectors import DefaultSelector, EVENT_WRITE, EVENT_READimport socketimport timeREQUEST_STR = '{method} {path} HTTP/1.0\\r\\n\\r\\n'JOBS_COUNT = 0select = DefaultSelector()class NoBlockClient:    def __init__(self):        self.result = []    def request(self, method, hostname, port, path):        global JOBS_COUNT        JOBS_COUNT += 1        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        sock.setblocking(False)        try:            sock.connect((hostname, port))        except BlockingIOError:            pass        select.register(sock.fileno(), EVENT_WRITE, partial(self._send, sock, method, path))    def _send(self, sock, method, path):        select.unregister(sock.fileno())        sock.send(REQUEST_STR.format(method=method, path=path).encode())        select.register(sock.fileno(), EVENT_READ, partial(self._recv, sock))    def _recv(self, sock):        global JOBS_COUNT        response_stream = sock.recv(1024)        if not response_stream:            select.unregister(sock.fileno())            sock.close()            JOBS_COUNT -= 1        else:            self.result.append(response_stream)    def run(self):        while JOBS_COUNT:            events = select.select()            for key, mask in events:                callback = key.data                callback()        return self.resultstart_time = time.time()count = 3no_block_client = NoBlockClient()for _ in range(count):    no_block_client.request("GET", "127.0.0.1", 8080, "/")result = no_block_client.run()print("{} 请求{}次, 运行时间: {:.1f}秒".format(NoBlockClient.__name__, count, time.time() - start_time))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行客户端：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; C:\\Users\\Administrator&gt;python no_block_client.pyNoBlockClient 请求3次, 运行时间: 1.0秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>非常明显的看见时间上的区别，虽然代码看起来特别的复杂，但是说的直白一点就是将每一个函数对应一个事件注册进sleelct中，由sleect进行监控，如果有事件触发就运行对应的函数。</p><p>我们分析下IO多路复用客户端代码：</p><ol><li><code>select = DefaultSelector()</code> 该行代码返回了当前平台IO多路复用最佳实现方式，分别为：select、poll、epoll、dev/poll、kqueue。由于我是使用win来测试，所以DefaultSelector()返回了select模型。</li><li><code>NoBlockClient.request</code> 函数的目的是创建一个非阻塞套接字连接至目标服务器，并将当前套接字注册进select中。当其状态为可写时，运行NoBlockClient._send，相当于一个回调函数。</li><li><code>NoBlockClient._send</code> 负责将消息发送至已连接的服务器，最后如同NoBlockClient.request一样注册事件选择回调函数。</li><li><code>NoBlockClient._recv</code> 当注册事件为可读时，将运行该函数，读取服务器返回数据，至此一次完整的请求就结束了。</li><li><code>NoBlockClient.run</code> 函数主要为了让select开始循环监听这些注册事件的状态，并运行回调函数。</li></ol><p>selectors模块是对select模块的封装，使得我们不用在意当前平台需要使用什么模型，而是直接返回当前平台最佳的模型，并将各个模型的API进行整合，让使用者能够更方便地写出跨平台代码。最经常使用的几种模型包括：select，poll，epoll。接下来将讲述这几种模型的区别、优缺点以及大概的实现方式。</p><ol><li>select：select将被注册的事件放入一个列表中并拷贝到内核空间进行监听。如果这些事件其中一个有了变化，那么select将再次把包含事件的列表拷贝进用户空间，这就造成了资源上的极大浪费。如果select只监听一个或者两个事件还好，但是当select需要监听的事件越来越多时，select的性能将会直线下降。而且select将时间拷贝到用户空间时并不会告诉用户哪一个事件被触发了，而是要用户自己去遍历。因为select监听的事件越多性能越差，所以通常系统内核都会对select模型监听数量进行限制。在Python源码中（<a href="https://github.com/python/cpython/blob/master/Modules/selectmodule.c">github: selectmodule.c</a>），使用宏定义将win中select监听事件限制在了512。当然，select的最大优点则是几乎所有的平台都支持select。</li><li>poll：其实现方式几乎与select相同，所以select有的缺点poll也拥有，这里就不多说了。详情见<a href="https://blog.csdn.net/luojian5900339/article/details/54581852">poll事件机制</a>。</li><li>epoll：epoll相比较select、poll有了质的改变，epoll将注册的事件都插入到了红黑树中，红黑树中的每一个节点都是一个注册的事件。由于红黑树查询、插入、删除时间复杂度都是O(logn)，所以epoll能够更加方便地对事件进行管理，并且其在事件被触发时仅仅返回被触发的事件，而不是像select全部返回，这大大增加了效率。更加详细的epoll模型介绍见<a href="https://blog.csdn.net/apacat/article/details/51375950">EPOLL的理解和深入分析</a>。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python dict</title>
      <link href="//post/dict.html"/>
      <url>//post/dict.html</url>
      
        <content type="html"><![CDATA[<p>Python的<code>dict</code>是一种映射类型，底层使用哈希表的方式来储存数据，因此<code>dict</code>的查询速度时间复杂度为O(1)，这是一种典型的空间换时间的数据结构。</p><p>当我们创建一个<code>key-value</code>时，首先将哈希函数作用于<code>key</code>上获得一个整型数组，将这个整型数字与储存<code>value</code>数组的长度取余，得到该数组的下标，该下标就是<code>value</code>所存放的位置。在初始化<code>dict</code>时，Python首先会申请一个大小为8KB左右的数组用来存放<code>value</code>（见<code>dictobject.c</code>第111行定义字典最小容量），如果数组位置不够存放则会再向系统申请两倍于当前容量的数组来存放<code>value</code>。</p><p>对于哈希冲突，Python选择了开放寻址法来解决：当产生哈希冲突时，通过探测函数计算出下一个候选位置，如果下一个候选位置还是有冲突，那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。</p><p><code>dict</code>的初始化在<a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c#L691">dictobject.PyDict_New:691</a>该函数中完成：</p><pre class="line-numbers language-none"><code class="language-none">PyObject * PyDict_New(void){    dictkeys_incref(Py_EMPTY_KEYS);    return new_dict(Py_EMPTY_KEYS, empty_values);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自Python 3.6以来，<code>dict</code>的键的顺序保持了插入时的顺序<a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c#L13">dictobject.c:13</a></p><pre class="line-numbers language-none"><code class="language-none">As of Python 3.6, this is compact and ordered. Basic idea is described here:* &lt;https://mail.python.org/pipermail/python-dev/2012-December/123028.html&gt;* &lt;https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>dict</code>的实现方式以及哈希冲突的解决方法都是Python的核心问题。了解这些内容对于Python的性能优化和底层实现有很大帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python深拷贝浅拷贝</title>
      <link href="//post/python-shen-kao-bei-qian-kao-bei.html"/>
      <url>//post/python-shen-kao-bei-qian-kao-bei.html</url>
      
        <content type="html"><![CDATA[<p>关于Python中的对象拷贝问题，我们需要了解is和==的区别:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; b = [1,2,3,4]&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bFalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中可以看出，a和b中的值是相等的，但是is的结果却不一样。这是因为Python比较的是a和b的值是否相等，而is比较的是对象的标识是否相等。因此，在Python中我们通常使用==来比较对象的值是否相等，使用is来判断对象绑定的值是否为None。需要注意的是，有一些初学者经常犯的错误是使用None来比较一个字符串、列表或字典是否为空，这是不正确的，因为这些变量无论从对象标识还是数值上都与None不相等。</p><p>在Python中，我们通常使用浅拷贝来复制对象。copy模块为我们提供了copy（浅拷贝）和deepcopy（深拷贝）函数。</p><p>浅拷贝指的是将拷贝的对象引用拷贝一份，拷贝对象指向的是被拷贝对象的值。换句话说，在原有值的基础上再添加了一份引用。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)4297636352&gt;&gt;&gt; id(b)4297636352<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>深拷贝指的是将拷贝对象的值复制一份，并新建一个对象，这个新的对象的值和对象标识都与被拷贝对象相等。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; b[1,2,3]&gt;&gt;&gt; a[1,2,3]&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; id(a)4297636352&gt;&gt;&gt; id(b)4297636352&gt;&gt;&gt; a.append(0)&gt;&gt;&gt; a[1,2,3,0]&gt;&gt;&gt; b[1,2,3]&gt;&gt;&gt; b.append(9)&gt;&gt;&gt; b[1, 2, 3, 9]&gt;&gt;&gt; a[1, 2, 3, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于这种现象，我们应该特别注意函数在使用可变参数作为默认参数时，如果不注意就会出现下面这种情况:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def a(x = []):...     x.append(0)...     print(x)&gt;&gt;&gt; a()[0]&gt;&gt;&gt; a()[0, 0]&gt;&gt;&gt; a()[0, 0, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种情况，我们应该避免使用可变对象作为函数默认参数:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def a(x = None):...     if x is None:...         x = []...     else:...         x.append(0)...     print(x)...&gt;&gt;&gt; a()[]&gt;&gt;&gt; a()[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在创建类初始化传参时也使用了浅拷贝来传递参数，这会导致下面这种情况：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; class A:...     def __init__(self, name):...         self.name = name...     def printf(self):...         print(self.name)...&gt;&gt;&gt; x = [1,2,3,4]&gt;&gt;&gt; a = A(x)&gt;&gt;&gt; a.printf()[1, 2, 3, 4]&gt;&gt;&gt; x.append(5)&gt;&gt;&gt; a.printf()[1, 2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当传入的参数发生改变时，类里面的变量的值也会随之改变，这种情况很难发现。深拷贝和浅拷贝的最大区别在于：深拷贝会拷贝父级对象及其子对象，而浅拷贝只拷贝父级对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端传给前端int 类型数据自增或自减</title>
      <link href="//post/hou-duan-chuan-gei-qian-duan-int-lei-xing-shu-ju-zi-zeng-huo-zi-jian.html"/>
      <url>//post/hou-duan-chuan-gei-qian-duan-int-lei-xing-shu-ju-zi-zeng-huo-zi-jian.html</url>
      
        <content type="html"><![CDATA[<p>由于我使用的是Python 3，Python 中的 int 类型与其他语言中的 int 类型不同，Python 将 long 类型也加入到了 int 中。因此，在其他语言中能够正确显示的 int 类型，在 Python 中不一定能够正确显示。当 Python 传递的 int 超过了浏览器所能解析的最大值时，就会出现这种情况。建议将较大的 int 类型转换成字符串后再传给前端。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python内置函数</title>
      <link href="//post/python-nei-zhi-han-shu.html"/>
      <url>//post/python-nei-zhi-han-shu.html</url>
      
        <content type="html"><![CDATA[<p>abs(x): 接受一个整数或浮点数作为参数，返回该参数的绝对值，如果该参数是一个复数，则返回复数的模。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(4 - 8j)8.94427190999916<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>all(iter): 接受一个可迭代类型，如果该参数内所有元素为真返回True，否则返回False。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; all([1,2,3,4,5])True&gt;&gt;&gt; all([1,2,3,4,0])False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>any(iter):接受一个可迭代类型为参数,如果该参数内任何元素为真,则返回True,否则返回False.</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; any([0, 0,1])True&gt;&gt;&gt; any([0, 0,0])False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>asicc(object):接受一个对象, 将调用该对象的__repr__方法, 返回的字符串会将\x,\u,\U进行转移输出.</p><pre class="line-numbers language-none"><code class="language-none">In [4]: class a:...:     def __repr__(self):...:         return "repr"In [5]: ascii(a())Out[5]: 'repr'In [9]: ascii("\n\rfdsafdsa")Out[9]: "'\\n\\rfdsafdsa'"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bin(x):接受一个整数作为参数, 并将该参数转换成以”0b”前缀的二进制字符串,如果x不是一个整数,那么将会调用对象的__index__方法的整数并转换成二进制.</p><pre class="line-numbers language-none"><code class="language-none">In [15]: class a:...:     def __index__(self):...:         return 1In [14]: bin(1)Out[14]: '0b1'In [16]: bin(a())Out[16]: '0b1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bool([x]):如果不传参数,则默认返回Fase,如果X是一个不是整数或浮点数则首先调用对象的__bool__方法, 如果对象的__bool__方法未定义,其次调用__len__方法,如果返回0则bool()返回False,否则返回True,如果对象__len__、__bool__方法都未定义则默认返回True</p><pre class="line-numbers language-none"><code class="language-none">In [39]: bool(1)Out[39]: TrueIn [40]: bool(0.0)Out[40]: FalseIn [41]: bool(0 - 0j)Out[41]: FalseIn [43]: class a:...:     def __bool__(self): return True...:     def __len__(self): return 0In [45]: bool(a())Out[45]: TrueIn [44]: bool(a)Out[44]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytearray([source[, encoding[, errors]]]):接受一个大于等于0小于256的整数或者一个可迭代类型、如果参数一个字符串,那么必须指定encoding. 返回一个新的字节数组.如果传入一个对象首先调用该对象__index__, 如果未定义__index__则调用对象__iter__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [64]: class a:...:     def __iter__(self):...:         for i in range(0, 256):...:             yield i...:     def __index__(self): return 1...:In [65]: bytearray(a())Out[65]: bytearray(b'\x00')In [48]: bytearray()Out[48]: bytearray(b'')In [49]: bytearray([1,2,3,4,5,6,7])Out[49]: bytearray(b'\x01\x02\x03\x04\x05\x06\x07')In [77]: bytearray(1)Out[77]: bytearray(b'\x00')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytes([source[, encoding[, errors]]]): 如同bytearray使用方法, 不过该函数返回的一个不可变类型.</p><pre class="line-numbers language-none"><code class="language-none">In [72]: class a:...:     def __iter__(self):...:         for i in range(0, 256):...:             yield i...:     def __index__(self): return 1...:In [73]: bytes(a())Out[73]: b'\x00'In [79]: bytes(1)Out[79]: b'\x00'In [80]: bytes()Out[80]: b''In [81]: bytes([1,2,3,4,5,6,7])Out[81]: b'\x01\x02\x03\x04\x05\x06\x07'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>callable(object):接受一个对象作为参数, 如果该参数是可以调用的则返回True, 否则返回False</p><pre class="line-numbers language-none"><code class="language-none">In [83]: class a:passIn [85]: callable(a)Out[85]: TrueIn [86]: callable(a())Out[86]: FalseIn [88]: class a:...:     def __call__(self):...:         return 1In [89]: callable(a())Out[89]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>chr(i): 接受一个整数, 返回该整数对应的Unicode代码点的字符串,该整数必须大于等于0,小于等于1114112.</p><pre class="line-numbers language-none"><code class="language-none">In [105]: chr(0)Out[105]: '\x00'In [99]: chr(1114111)Out[99]: '\U0010ffff'In [100]: chr(1114112) # 超出范围---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-100-4857faf08086&gt; in &lt;module&gt;----&gt; 1 chr(1114112)ValueError: chr() arg not in range(0x110000)==<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@classmethod:装饰器, 作用于类方法上, 被装饰的方法将转换成类方法,类方法的一个参数将是类本身.</p><pre class="line-numbers language-none"><code class="language-none">In [110]: class a:...:     def a1(self):...:         print(self)...:     @classmethod...:     def a2(self): # 按照约定应该将self修改成cls来从字面量上区分类方法和实例方法....:         print(self)...:In [111]: a().a1() # 实例方法&lt;__main__.a object at 0x00000245CBE815C0&gt;In [112]: a.a2() # 类方法&lt;class '__main__.a'&gt;In [113]: a().a2() # 实例可以调用类方法&lt;class '__main__.a'&gt;In [115]: a.a1() # 类在未实例化之前不能调用实例化方法, 当然有捷径可以走,这里只是做了一个区分, 不展示捷径---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-115-2656506098d9&gt; in &lt;module&gt;----&gt; 1 a.a1()TypeError: a1() missing 1 required positional argument: 'self'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):将一个字符串编译成字节代码:</p><pre class="line-numbers language-none"><code class="language-none">source: 字符串或者AST对象,filename: 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值, 如’’.mode: 指定编译代码的种类。可以指定为 exec, eval, singleflags: 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。flags和dont_inherit是用来控制编译源码时的标志In [121]: d = compile("print(1)", "", "exec")In [122]: dOut[122]: &lt;code object &lt;module&gt; at 0x00000245CBF448A0, file "", line 1&gt;In [123]: exec(d)1complex([real[, imag]]): 创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In [125]: complex(1, 2)<br>Out[125]: (1+2j)<br>In [127]: complex(“1”)<br>Out[127]: (1+0j)<br>In [128]: complex(“1+2j”) # 此处不能有空格, 否则会报错<br>Out[128]: (1+2j)<br>delattr(object, name): 接受一个对象以及一个字符串,删除该对象的name属性,也可以使用del object.name来实现.</p><pre class="line-numbers language-none"><code class="language-none">In [144]: class a:...:     x = 1...:     y = 2...:In [145]: delattr(a, "x")In [147]: a.x---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-147-e27186f28a17&gt; in &lt;module&gt;----&gt; 1 a.xAttributeError: type object 'a' has no attribute 'x'In [148]: a.yOut[148]: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dict([object]):用于创建一个字典.如果不传参数,则返回一个空的字典.</p><pre class="line-numbers language-none"><code class="language-none">In [150]: dict()Out[150]: {}In [151]: dict(a=1, b=2)Out[151]: {'a': 1, 'b': 2}In [152]: dict({"a":1})Out[152]: {'a': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dir([object]):不传参数时, 返回当前范围内变量、方法和定义的类型列表,传入参数时返回该参数的所有的属性、方法, 如果该参数定义了__dir__方法, 则使用__dir__返回值, 否则该函数将尽可能的最大限度的收集该对象的方法以及属性.</p><pre class="line-numbers language-none"><code class="language-none">In [157]: dir("")Out[157]:['__add__','__class__','__contains__',...]In [155]: class a:...:     def __dir__(self):...:         return ["a", "b"]...:In [156]: dir(a())Out[156]: ['a', 'b']In [158]: class a:...:     x = 1...:     y = 2...:In [159]: dir(a)[...,'x','y']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>divmod(x, y): 接受两个非复数的数字作为参数, 返回X,Y的商和余.</p><pre class="line-numbers language-none"><code class="language-none">In [160]: divmod(1, 2)Out[160]: (0, 1)In [161]: divmod(1.5, 2)Out[161]: (0.0, 1.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>enumerate(iterable, start=0):接受一个可迭代类型以及一个可选int类型的参数, 返回一个枚举对象.如果指定了start则该可迭代对象的下边从start开始.</p><pre class="line-numbers language-none"><code class="language-none">In [163]: enumerate([1,2,3,4])Out[163]: &lt;enumerate at 0x245cbf50438&gt;In [164]: list(enumerate([1,2,3,4]))Out[164]: [(0, 1), (1, 2), (2, 3), (3, 4)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>eval(expression, globals=None, locals=None):接受一个字符串类型的表达式, 并执行该表达式,返回其值.</p><pre class="line-numbers language-none"><code class="language-none">expression: 字符串类型的表达式.globals: 字典类型, 变量作用域，全局命名空间.locals: 任何的映射对象, 变量作用域，局部命名空间.In [166]: eval("1 + 2")Out[166]: 3exec(object[, globals[, locals]]):该函数提供动态执行python代码的功能,object可以是字符串也可以是一个代码对象. globals必须是一个字典,locals则可以是任何的映射对象,In [168]: x = 1In [169]: exec("x + 2")In [172]: xOut[172]: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>filter(function,iterable):接受一个函数对象以及一个可迭代对象作为参数, 将可迭代对象中的每一个元素传入第一个参数中,如果该函数返回True则保留当前元素,否则删除当前元素.filter函数返回一个可迭代对象.</p><pre class="line-numbers language-none"><code class="language-none">In [3]: list(filter(lambda x: False, [1,2,3,4]))Out[3]: []In [4]: list(filter(lambda x: True, [1,2,3,4]))Out[4]: [1, 2, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>float([x]): 接受一个可选整型、浮点型、对象或者字符串类型参数, 返回该参数的浮点类型数据,如果X是一个自定义对象那么将调用对象的__float__方法(仅提供用方法, 完整方法见:float).</p><pre class="line-numbers language-none"><code class="language-none">In [6]: float("+1")Out[6]: 1.0In [7]: float("-1")Out[7]: -1.0In [8]: float("Inf")Out[8]: infIn [11]: float(1)Out[11]: 1.0In [12]: float(1.2)Out[12]: 1.2# 自定义对象In [14]: class a:...:     def __float__(self): return 1.0...:In [15]: float(a())Out[15]: 1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>format(value[,format_spec]):格式化字符串函数, 接受不限个参数，位置可以不按顺序, 其数字格式化符号见菜鸟教程, 对于自定义对象, 则调用对象的__format__方法, 如果对象没有定义__format__则使用对象__str__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [20]: "{}|{}".format(1, "dsa")Out[20]: '1|dsa'In [21]: "{1}|{0}".format(1, "dsa")Out[21]: 'dsa|1'In [22]: "{0}|{1}".format(1, "dsa")Out[22]: '1|dsa'In [23]: "{:.2f}".format(1.235646)Out[23]: '1.24'In [33]: class a:...:     def __format__(self, *args):...:         return "format"...:In [34]: "{}".format(a())Out[34]: 'format'In [36]: class a:...:     def __str__(self):...:         return "str"...:In [37]: "{}".format(a())Out[37]: 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>frozenset([iterable]): 接受一个可选的可迭代类型的参数, 返回一个frozenset对象, 该对象与set对象基本相似, 但是该对象是不可变的.</p><pre class="line-numbers language-none"><code class="language-none">In [39]: frozenset()Out[39]: frozenset()In [40]: frozenset([1,2,1,1])Out[40]: frozenset({1, 2})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getattr(object,name[,default]): 接受两个必选参数和一个可选参数, 该函数返回了object.name的值, 如果不存在name属性,并且没有传入default参数时则触发异常, 如果传入了default参数则没有找到name属性时返回default.</p><pre class="line-numbers language-none"><code class="language-none">In [45]: class a:...:     def b(self):...:         return "2"In [47]: getattr(a(), "b")()Out[47]: '2'getattr(a(), "b1", lambda : print("b1"))()b1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>globals(): 返回当前所有全局变量的字典.</p><pre class="line-numbers language-none"><code class="language-none">In [49]: globals()Out[49]:{'__name__': '__main__','__doc__': 'Automatically created module for IPython interactive environment','__package__': None,...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hasattr(object, name): 接受两个必选参数, 检测object中是否有那么属性.如果有name属性返回True,否则返回False.</p><pre class="line-numbers language-none"><code class="language-none">In [50]: class a:...:     b = 1...:In [51]: hasattr(a, "b")Out[51]: TrueIn [52]: hasattr(a, "b1")Out[52]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hash(object): 接受一个必选参数, 返回该对象的整型哈希值, 如果时自定义对象则调用对象的__hash__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [56]: hash("fdsaf")Out[56]: 2111967917974353823In [58]: class a:...:     def __hash__(self):...:         return 9527...:In [59]: hash(a())Out[59]: 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>help([object]): 接受一个可选的参数, 该参数可以是任意的类型, 返回该对象的帮助文档, 如果是自定义对象, 则返回该函数或者类的注释.如果没有传入参数则拉起交互式的帮助系统</p><pre class="line-numbers language-none"><code class="language-none">In [62]: help(1)Help on int object:class int(object)|  int(x=0) -&gt; integer...In [65]: class a:...:     """这是help信息"""...:     def b(self):...:         """这也是help信息"""...:         passIn [66]: help(a())Help on a in module __main__ object:class a(builtins.object)|  这是help信息||  Methods defined here:||  b(self)|      这也是help信息||  ----------------------------------------------------------------------|  Data descriptors defined here:||  __dict__|      dictionary for instance variables (if defined)||  __weakref__|      list of weak references to the object (if defined)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hex(x):接受一个整型作为必选参数, 返回该参数的16进制字符串, 该字符串以0x开头,如果x是一个自定义对象那么该对象必须实现__index__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [72]: hex(185)Out[72]: '0xb9'In [74]: class a:...:     def __index__(self): return 1In [75]: hex(a())Out[75]: '0x1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>id(object): 返回该对象在内存中的地址以整型返回.</p><pre class="line-numbers language-none"><code class="language-none">In [77]: id(1)Out[77]: 1786755536In [81]: class a:...:     def __init__(self, x):...:         self.x = x...:In [82]: id(a(1)) == id(2)Out[82]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>input([prompt]): 从标准输入中读取输入一回车键结束, 如果传入prompt, 则将prompt打印到标准输出中.</p><pre class="line-numbers language-none"><code class="language-none">In [84]: input("这是提示:")这是提示:ddOut[84]: 'dd'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>int(x, base=10):将一个字符串或数字转换为整型,如果没有传入参数则返回0,如果传入传入了base则表示X是base进制的数字.如果X是一个自定义对象, 则调用__init__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [86]: int()Out[86]: 0In [87]: int(1.0)Out[87]: 1In [90]: int("0x9b", 16)Out[90]: 155In [91]: class a:...:     def __int__(self):...:         return 1In [92]: int(a())Out[92]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>isinstance(object, classinfo):如果object是classinfo的实例或者子类的实例, 返回True, 否则返回False.如果classinfo是一个元组, 那么object只要是元组中任意一个元素的子类的实例或者实例化都返回True.</p><pre class="line-numbers language-none"><code class="language-none">In [94]: class a: passIn [95]: class b(a): passIn [99]: isinstance(b(), a)Out[99]: TrueIn [101]: isinstance(1, int)Out[101]: TrueIn [103]: isinstance(1, str)Out[103]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>issubclass(class, classinfo):如果class是classinfo的子类返回true, 使用方法与isinstance相同.</p><pre class="line-numbers language-none"><code class="language-none">In [94]: class a: passIn [95]: class b(a): passIn [105]: issubclass(b, a)Out[105]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>iter(object[,sentinel]):返回一个迭代器对象, 如果没有传入第二个参数, 那么object必须是实现了迭代协议或者序列协议否则将触发TypeError, 如果传入了sentinel参数那么object必须是可调用对象, 此时每迭代一次都调用object,如果object返回的值等于sentinel时,触发StopIteration异常.</p><pre class="line-numbers language-none"><code class="language-none">In [108]: iter([1,2,3])Out[108]: &lt;list_iterator at 0x210bde35f98&gt;In [110]: class a:...:     def __iter__(self):...:         for i in range(10):...:             yield i...:In [111]: list(iter(a()))Out[111]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [12]: def a():...:     global num...:     num += 1...:     if num &gt;= 10:...:         return -1...:     return numIn [13]: for i in iter(a, -1):...:     print(i)123456789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>len(s): 接受一个序列或者集合类型对象, 返回其长度, 如果时自定义对象, 将会调用对象的__len__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [18]: len([1,2,3])Out[18]: 3In [19]: len({1:2, 3:4})Out[19]: 2In [20]: class a:...:     def __len__(self): return 1In [21]: len(a())Out[21]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>locals():返回当前本地和只有变量的值.</p><pre class="line-numbers language-none"><code class="language-none">In [24]: def a():...:     x = 1...:     print(locals())In [25]: a(){'x': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>map(function,iterable…):返回一个迭代器, 该函数将function应用与每一个iterable元素上并返回直到可迭代对象耗尽.</p><pre class="line-numbers language-none"><code class="language-none">In [27]: map(lambda x: x ** 2, [1,2,3])Out[27]: &lt;map at 0x2aec3ae4a20&gt;In [28]: list(map(lambda x: x ** 2, [1,2,3]))Out[28]: [1, 4, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>max(arg1,arg2,*args[,key]):接受多个位置参数或者一个可迭代对象, 返回其中最大的值.</p><pre class="line-numbers language-none"><code class="language-none">In [39]: max(1,2)Out[39]: 2In [40]: max([2,3,4,5])Out[40]: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>memoryview(obj): 返回obj的内存查看对象(对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问).</p><pre class="line-numbers language-none"><code class="language-none">In [43]: a = b"dsadsad"In [44]: d = memoryview(a)In [47]: d[0]Out[47]: 10# 未复制数据In [52]: id(d.obj)Out[52]: 2949631565952In [53]: id(a)Out[53]: 2949631565952<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>min(arg1，arg2，* args[，key]): 接受多个位置参数或者一个可迭代对象, 返回其中最小的值.</p><pre class="line-numbers language-none"><code class="language-none">In [55]: min(1,2)Out[55]: 1In [56]: min([1,2,3,5])Out[56]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>next(iterator[,default]): 通过调用iterator的__next__方法并返回其值.</p><pre class="line-numbers language-none"><code class="language-none">In [58]: class a:...:     def __next__(self):...:         for i in range(10):...:             yield iIn [60]: list(next(a()))Out[60]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>object(): 返回一个新的无任何特征的对象, object时所有class的基类.</p><pre class="line-numbers language-none"><code class="language-none">In [105]: object()Out[105]: &lt;object at 0x2aec3a34880&gt;In [106]: class a:passIn [107]: issubclass(a, object)Out[107]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>oct(x):接受一个整型作为参数返回以”0o”为前缀的八进制字符串,如果x是自定义对象, 则调用该对象的__index__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [109]: oct(1)Out[109]: '0o1'In [111]: class a:...:     def __index__(self): return 1In [112]: oct(a())Out[112]: '0o1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>open(file,mode=’r’,buffering=-1,encoding=None,errors=None,newline=None,<br>closefd=True,opener=None):打开file文件并返回一个文件对象, 具体参数值见open.</p><pre class="line-numbers language-none"><code class="language-none">file: 文件所在的路径以及文件名mode: 打开文件的模式, 默认"r”buffering: 用于设置缓冲策略, 0为关闭缓冲, 1为选择行缓冲, &gt; 1以指示固定大小的块缓存区.默认-1,二进制文件以固定大小的块缓冲 4.encoding:用于解码或编码文件的编码的名称, 默认编码取决于所在的操作系统 5.errors:指定如何处理编码和解码错误, 仅能在文本模式下使用 6.newline: 控制通用换行模式的工作方式（仅适用于文本模式）。它可以是None，''，'\n’，'\r’，和’\r\n’In [114]: open("test.test", "w").write("fdsa")Out[114]: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ord(c): 接受一个字符串类型参数, 返回该Unicode代码点的整数.</p><pre class="line-numbers language-none"><code class="language-none">In [116]: ord("a")Out[116]: 97In [117]: ord("你")Out[117]: 20320<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pow(x,y[,z]):当未传入Z参数时,返回x的y次方,如果传入了Z则对结果取余.</p><pre class="line-numbers language-none"><code class="language-none">In [122]: pow(2,3)Out[122]: 8In [124]: pow(2,3, 2)Out[124]: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>print(*objects,sep=’ ‘,end=’\n’,file=sys.stdout,flush=False):将objects对象打印到标准输出中,每一个objects使用sep分割, 以end结束,对于自定义对象, 首先调用对象__str__方法, 如果没有定义__str__方法则调用__repr__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [136]: class a:...:     def __str__(self): return "str"...:     def __repr__(self): return "repr"In [137]: print(a())str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>property(fget=None，fset=None，fdel=None，doc=None): 可作为装饰器使用也可作为函数使用.用于显示类属性的读取、设置以及删除. 作为函数使用时:</p><pre class="line-numbers language-none"><code class="language-none">In [140]: class a:...:     def __init__(self):...:         self._x = None...:...:     def getx(self):...:         return self._x...:...:     def setx(self, x):...:         self._x = x...:     def delx(self):...:         self._x = None...:     x = property(getx, setx, delx, "test")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为装饰器使用时:</p><pre class="line-numbers language-none"><code class="language-none">class a:def __init__(self):self._x = None@propertydef x(self):return self._x@x.fsetdef x(self, x):self._x = x@x.fdeldef x(self):self._x = None参数:fget – 获取属性值的函数fset – 设置属性值的函数fdel – 删除属性值函数doc – 属性描述信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>range(start,stop[,step]):range并不是一个函数, range时一个不可变序列类型,返回一个迭代器对象.</p><pre class="line-numbers language-none"><code class="language-none">In [149]: list(range(1, 10, 2))Out[149]: [1, 3, 5, 7, 9]In [150]: list(range(1, 10))Out[150]: [1, 2, 3, 4, 5, 6, 7, 8, 9]In [151]: list(range(10))Out[151]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [152]: type(range) # 非函数Out[152]: type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repr(object): 返回可打印的字符串,此函数尝试返回一个字符串，该字符串在传递时会产生具有相同值的对象eval()，否则表示形式是一个括在尖括号中的字符串，其中包含对象类型的名称以及其他信息通常包括对象的名称和地址。类可以通过定义__repr__()方法来控制此函数为其实例返回的内容.</p><pre class="line-numbers language-none"><code class="language-none">In [154]: repr(1)Out[154]: '1'In [155]: class a:...:     def __repr__(self): return "1"In [156]: repr(a())Out[156]: '1'In [157]: repr(a)Out[157]: "&lt;class '__main__.a'&gt;"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reversed(seq):接受一个可迭代类型, 返回该可迭代类型的反向迭代器.</p><pre class="line-numbers language-none"><code class="language-none">In [161]: list(reversed(range(10)))Out[161]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>round(num, [, ndigits]): 返回num四舍五入精确到ndigits精度数字, 如果没有传入ndigits则返回最接近num的整数, 如果num时一个自定义对象, 则调用__round__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [163]: round(1.2563, 2)Out[163]: 1.26In [164]: round(1.2563)Out[164]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>set([iterable]):返回一个新的set类型对象, 接受可选可迭代类型参数, 并将可迭代类型参数转换成set类型返回.</p><pre class="line-numbers language-none"><code class="language-none">In [166]: set()Out[166]: set()In [167]: set([1,2,3])Out[167]: {1, 2, 3}In [168]: set(range(10))Out[168]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>setattr(object, name, value): 接受三个必选参数, 将object.name属性赋值为value.</p><pre class="line-numbers language-none"><code class="language-none">In [172]: class a: passIn [173]: a1 = a()In [174]: setattr(a1, "b", 1)In [175]: a1.bOut[175]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slice(start,stop[,step]):返回表示由指定的索引集的切片对象, 该对象为只读数据属性.</p><pre class="line-numbers language-none"><code class="language-none">In [178]: slice(0, 1)Out[178]: slice(0, 1, None)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>sorted(iterable,*,key=None,reverse=False):将_iterable_对象排序后返回.</p><pre class="line-numbers language-none"><code class="language-none">key: 可选关键字参数,_key_指定一个参数的函数，该函数用于从_iterable中的_每个元素中提取比较键reverse: 可选关键字参数, 如果设置为True，则列表元素将按照每个比较相反的方式进行排序.In [181]: sorted(["12", "1", "34", "6", "90"], key=int)Out[181]: ['1', '6', '12', '34', '90']In [182]: sorted(["12", "1", "34", "6", "90"], key=int, reverse=True)Out[182]: ['90', '34', '12', '6', '1']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@staticmethod: 装饰器函数, 作用于类方法上, 将方法转换成静态方法.</p><pre class="line-numbers language-none"><code class="language-none">In [185]: class a:...:     @staticmethod...:     def b(x):...:         return xIn [186]: a.b(1)Out[186]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>str(object=b’’,encoding=’utf-8’,errors=’strict’):返回一个字符串类型的对象,如果object是一个自定义对象, 那么首先会调用对象的__str__方法, 如果没有实现__str__方法则调用__repr__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [194]: class a:...:     def __repr__(self): return "re"...:     def __str__(self): return "str"In [195]: str(a())Out[195]: 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sum(iterable[,start]):如果没有传入_start_参数, 则将_iterable_所有的元素叠加后返回, 如果传入了_start_参数,则从_start_参数开始将_iterable_的元素从左至右的叠加.</p><pre class="line-numbers language-none"><code class="language-none">In [201]: sum([1,2,3], 8)Out[201]: 14In [207]: sum(range(1, 101))Out[207]: 5050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>super([type[,object-or-type]]):该函数用于调用父类(超类)的一个方法.</p><pre class="line-numbers language-none"><code class="language-none">In [209]: class a:...:     def add(self, x):...:         return x + 1In [210]: class b(a):...:     def add(self, x):...:         return super().add(x)In [211]: b().add(1)Out[212]: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tuple([iterable]):返回一个元组对象, 接受一个可选的可迭代参数, 如果传入了该参数则将该参数转换成元组对象.</p><pre class="line-numbers language-none"><code class="language-none">In [214]: tuple([1,2,3,4])Out[214]: (1, 2, 3, 4)In [215]: tuple()Out[215]: ()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>type(name,bases,dict):只传入一个参数时将返回该参数的类型,使用三个参数，返回一个新类型对象,name则成为类对象的名称,base则表明了其父类, 可选的关键字参数则将成为类的属性.(type是类型实例关系的顶端, object是父子关系的顶端，所有的数据类型的父类都是它, Object是type的一个实例,Type是object的子类, 详细见type和object之间的关系)</p><pre class="line-numbers language-none"><code class="language-none">In [222]: d = type("objects", (), {"names": "this is name"})In [223]: dOut[223]: __main__.objectsIn [224]: d.namesOut[224]: 'this is name'In [217]: type(1)Out[217]: int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vars([object]):返回模块、类、实例、其他对象的__dict__属性.</p><pre class="line-numbers language-none"><code class="language-none">In [232]: class a:...:     x = 1In [233]: vars(a)Out[233]:mappingproxy({'__module__': '__main__','x': 1,'__dict__': &lt;attribute '__dict__' of 'a' objects&gt;,'__weakref__': &lt;attribute '__weakref__' of 'a' objects&gt;,'__doc__': None})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zip(*iterables):将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表,如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同.</p><pre class="line-numbers language-none"><code class="language-none">In [237]: zip([1,2,3,4], ["q", "w", "e", "r"])Out[237]: &lt;zip at 0x2aec3ad6d88&gt;In [238]: list(zip([1,2,3,4], ["q", "w", "e", "r"]))Out[238]: [(1, 'q'), (2, 'w'), (3, 'e'), (4, 'r')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>import(name,globals=None,locals=None,fromlist=(),level=0):import 语句将会调用该函数,该函数导入模块_name_, 使用给定的_globals和_locals来确定如何解释包上下文中的名称.</p><pre class="line-numbers language-none"><code class="language-none">In [240]: __import__("requests")Out[240]: &lt;module 'requests' from 'd:\\anaconda3\\envs\\python3\\lib\\site-packages\\requests\\__init__.py'&gt;In [241]: requests = __import__("requests")In [242]: requests.__version__Out[242]: '2.21.0'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aiohttp,asyncio,RunTimeError</title>
      <link href="//post/aiohttp-asyncio-runtimeerror.html"/>
      <url>//post/aiohttp-asyncio-runtimeerror.html</url>
      
        <content type="html"><![CDATA[<p>首先，你可能遇到了AssertionError: There is no current event loop in thread ‘Thread-1’。这是因为asyncio程序中的每个线程都有自己的事件循环，但只有在主线程中才会自动创建一个事件循环。因此，如果你在子线程中调用asyncio.get_event_loop()，你将会遇到此错误。</p><p>为了解决这个问题，你需要在启动线程时显式地创建和设置事件循环，示例代码如下：</p><pre class="line-numbers language-none"><code class="language-none">loop = asyncio.new_event_loop()asyncio.set_event_loop(loop)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一旦这样做，你应该就能够使用get_event_loop()在特定的线程中正常工作了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--dict的优点以及缺点</title>
      <link href="//post/liu-chang-de-python-dict-de-you-dian-yi-ji-que-dian.html"/>
      <url>//post/liu-chang-de-python-dict-de-you-dian-yi-ji-que-dian.html</url>
      
        <content type="html"><![CDATA[<p>以下是Python中字典的一些特点：</p><ol><li>健必须是可散列的。这意味着键必须支持hash()函数，并且通过hash()方法得到的散列值是不变的。此外，它们还必须支持eq()方法以检测相等性。如果a == b，则hash(a) == hash(b)。</li><li>字典内存开销大。由于字典是由散列表实现的，散列表中可能会有一些稀疏性，这会占用一些空间。与字典的速度相比，这些内存消耗可以忽略不计。</li><li>字典的键顺序不是唯一的。由于散列表在插入或读取时可能会产生散列冲突，因此字典中键的顺序不是唯一的。但是，不管字典键的顺序如何变化，如果两个字典键值对都相同，则这两个字典是相等的。</li></ol><pre class="line-numbers language-none"><code class="language-none">a = {    "1": 1,    "2": 3,    "3": 4,    "4": 4}b = {    "3": 3,    "4": 4,    "1": 1,    "2": 2}a == bTrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--字典中的散列表</title>
      <link href="//post/liu-chang-de-python-zi-dian-zhong-de-san-lie-biao.html"/>
      <url>//post/liu-chang-de-python-zi-dian-zhong-de-san-lie-biao.html</url>
      
        <content type="html"><![CDATA[<p>字典中的散列表其实就是稀疏数组，也就是说有些元素是空的。在构建字典时，会有两个表元，一个用来标记键，一个用来标记值。因为两个表元的长度相等，所以可以通过表元的偏移量来查找字典。</p><p>在Python中，最有效率的内置数据类型是字典和集合，这两种数据类型都是通过散列表实现的。为了测试Python中不同数据类型的速度，我进行了以下实验：</p><pre class="line-numbers language-none"><code class="language-none">import timeMAX = 10000000list_a = [i for i in range(MAX)]set_a = set(list_a)dict_a = {}.fromkeys(list_a)test = [i for i in range(1000)]def testTime(x,name):    start = time.clock()    for i in test:        if i in x:            pass    print name,':','%f' % (time.clock() - start)testTime(list_a, 'list')testTime(set_a, 'set')testTime(dict_a, 'dict')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-none"><code class="language-none">list : 0.012472set : 0.000079dict : 0.000071<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从上面可以看出，集合与字典相比其他类型要快得多，这是因为列表中没有散列表支持in运算符。</p><p>散列的算法是这样的：比如Python要获取<code>dict[key]</code>背后的值，Python会先使用<code>hash(key)</code>来计算key的散列值，然后取散列值的最低位的几位数字作为表元的偏移量。如果表元为空，就会抛出一个<code>KeyError</code>异常；如果找到，就会获得一个<code>key:value</code>值，Python再最后会比较两个key的散列值是否一致。如果为真返回value，如果不相等则称为散列冲突。这种情况的发生是因为散列表把随机的元素映射到几位数字上去，而散列表需要依赖这个数字做检索。为了解决这个问题，散列表会再从新取几位数字，去表元中寻找。如果表元为空，就会抛出一个<code>KeyError</code>异常；如果没有找到，就会重复上面的步骤直到找到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--特殊方法</title>
      <link href="//post/liu-chang-de-python-te-shu-fang-fa.html"/>
      <url>//post/liu-chang-de-python-te-shu-fang-fa.html</url>
      
        <content type="html"><![CDATA[<p>Python中的特殊方法主要是被Python解释器调用，大部分情况下不需要自己实现特殊方法，比如<code>len(x)</code>，实际上是调用了<code>len()</code>方法。在实际编程中，我们不会使用<code>x.len()</code>这样的写法。如果<code>x</code>是一个自己实现的类并且在类里面实现了一个<code>len()</code>方法，那么Python就会调用这个类里面的方法。</p><p>大部分情况下，调用特殊方法都是隐式调用。例如：<code>for i in x:</code>，实际上是调用了<code>x</code>的<code>iter()</code>方法。所有的特殊方法都可以自定义，但在编程时不建议大量实现特殊方法，除非进行元编程。</p><p>因此，在自定义类时应该遵循Python的惯例，尽可能使用Python内置的方法和函数，而不是过度实现特殊方法。这样可以提高代码可读性和可维护性。同时，合理地实现特殊方法也是元编程的一种方式，可以实现更高级的功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python根据exif信息旋转图片</title>
      <link href="//post/python-gen-ju-exif-xin-xi-xuan-zhuan-tu-pian.html"/>
      <url>//post/python-gen-ju-exif-xin-xi-xuan-zhuan-tu-pian.html</url>
      
        <content type="html"><![CDATA[<p>最近写业务代码时遇到了一个需求：压缩图片。这本应该是一个简单的需求，三下五除二就能解决。但是当我用手机上传图片时，发现压缩后的图片都歪了。经过查找，发现问题出在图片的exif信息中的Orientation记录，它记录了图片的旋转角度。因此，需要根据这个角度来旋转图片。</p><p>首先需要读取图片的exif信息，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">from PIL import Imageimg = Image.open('1.jpg')# 先判断图片是否有exif信息if hasattr(img, '_getexif'):    # 获取exif信息    dict_exif = img._getexif()    if dict_exif.get(274, 0) == 3:        # 旋转        new_img = img.rotate(-90)    elif dict_exif.get(274, 0) == 6:        # 旋转        new_img = img.rotate(180)    else:        new_img = imgelse:    new_img = imgnew_img.save('new_1.jpg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个代码，我们可以获取图片的exif信息，并根据其中的Orientation记录来旋转图片。最终，我们得到了正确的压缩后的图片。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的高级用法 -- namedtuple</title>
      <link href="//post/python-de-gao-ji-yong-fa-namedtuple.html"/>
      <url>//post/python-de-gao-ji-yong-fa-namedtuple.html</url>
      
        <content type="html"><![CDATA[<p><code>namedtuple</code> 函数可以用来创建一个有名字的元组或者类，这种方法可以更有效的调试代码。下面是一个例子：</p><pre class="line-numbers language-none"><code class="language-none">from collections import namedtuple# 创建一个类a = namedtuple('c', ('name', 'age'))x = a('perror', 21)# 该返回值可以用访问对象的方法来访问print(x.name)print(x.age)# 也可以用标的方式去访问print(x[0])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了继承普通元组的方法外，命名元组还有额外的三个方法：<code>_fields</code> 类属性，<code>make()</code> 类方法，<code>_asdict()</code> 类实例方法。</p><p>下面是这些方法的具体用法：</p><pre class="line-numbers language-none"><code class="language-none"># 查看该命名元组中的所有字段print(x._fields)# `_make` 通过一个可迭代对象来生成一个类实例s = ('perror', '21')new_s = x._make(s)# 通过类实例方法更友好的打印出元组的字段print(new_s._asdict())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，命名元组创建后，可以用其属性名或标的方式来访问其中的元素。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
