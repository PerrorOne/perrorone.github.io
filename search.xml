<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>install fluxcd in k8s 1.25.5</title>
      <link href="/2023/02/18/install-fluxcd-in-k8s-1-25-5/"/>
      <url>/2023/02/18/install-fluxcd-in-k8s-1-25-5/</url>
      
        <content type="html"><![CDATA[<ol><li>install the flux cli: <code>brew install fluxcd/tap/flux</code></li><li>show the flux cli version: <code>flux version</code><pre class="line-numbers language-none"><code class="language-none">   ➜  ~ flux versionflux: v0.39.0helm-controller: v0.26.0image-automation-controller: v0.26.1image-reflector-controller: v0.22.1kustomize-controller: v0.30.0notification-controller: v0.28.0source-controller: v0.31.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>create git repo on github</li><li>set GITHUB_TOKEN env</li><li>install the flux cd to k8s: <code>flux bootstrap github --owner=&lt;you-github-name&gt; --repository=&lt;you-repo&gt; --path=./ --components-extra=image-reflector-controller,image-automation-controller  --read-write-key --branch=main</code>, <em>Don’t forget <code>--components-extra=image-reflector-controller,image-automation-controller</code></em>, Only when this parameter is used can image-related pods be created.</li><li>wait flux cd pod up.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql error: rec.cc:391 thread </title>
      <link href="/2023/02/18/mysql-error-rec-cc-391-thread/"/>
      <url>/2023/02/18/mysql-error-rec-cc-391-thread/</url>
      
        <content type="html"><![CDATA[<p>This error only in the mysql 8.0.30 version.see <a href="https://bugs.mysql.com/bug.php?id=107941">https://bugs.mysql.com/bug.php?id=107941</a> bug report. Upgrade mysql version to 8.0.31 to resolve this error</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何清理 Kubernetes namespace 中的 finalizers 并成功删除 argocd namespace</title>
      <link href="/2023/02/18/ru-he-qing-li-kubernetes-namespace-zhong-de-finalizers-bing-cheng-gong-shan-chu-argocd-namespace/"/>
      <url>/2023/02/18/ru-he-qing-li-kubernetes-namespace-zhong-de-finalizers-bing-cheng-gong-shan-chu-argocd-namespace/</url>
      
        <content type="html"><![CDATA[<p>在删除 Kubernetes 集群中的资源时，我遵循以下步骤：</p><ol><li>删除所有 <code>deploy</code>。</li><li>删除所有 <code>configmap</code>。</li><li>删除所有 <code>namespace</code>。</li></ol><p>&amp;nbsp;&amp;nbsp;然而，我发现在删除 <code>namespace</code> 时出现了问题。尝试了官方提供的命令<br><code>kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</code><br>但是 <code>namespace</code> 删除仍然被卡住了。我注意到该 <code>namespace</code> 下存在多个 <code>argoproj.io/v1alpha1/applications</code> 资源，并且所有资源都包含一个 <code>finalizers</code> 字段。通过搜索引擎，我了解到只有删除所有资源 YAML 文件中的 <code>finalizers</code> 字段才能解决 <code>namespace</code> 删除被卡住的问题。因此，我直接删除了 <code>finalizers</code> 字段并更新了所有资源，直到所有资源都被修改好为止。最终，<code>namespace</code> 能够被成功删除。<br>&amp;nbsp;&amp;nbsp;在 Kubernetes 中，删除某些资源时，这些资源可能具有关联的其他资源，这些关联资源需要被清理，以便能够顺利删除要删除的资源。当某个 <code>namespace</code> 中存在关联资源时，删除该 <code>namespace</code> 可能会失败。在这种情况下，Kubernetes 会在 <code>namespace</code> 对应的 <code>finalizers</code> 列表中添加一些条目，以确保所有关联资源被清理，然后再删除 <code>namespace</code>。在删除 <code>namespace</code> 时，Kubernetes 会检查 <code>finalizers</code> 列表中的所有条目，确保这些条目对应的所有资源已被清理，然后才会继续删除 <code>namespace</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helm 报错：another operation (install/upgrade/rollback) is in progress处理方法</title>
      <link href="/2023/02/18/helm-bao-cuo-another-operation-install-upgrade-rollback-is-in-progress-chu-li-fang-fa/"/>
      <url>/2023/02/18/helm-bao-cuo-another-operation-install-upgrade-rollback-is-in-progress-chu-li-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>使用flux cd来管理helmreleases</p><h3 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h3><p>单个helmrelease报错：another operation (install/upgrade/rollback) is in progress。</p><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol><li>运行 <code>helm history &lt;name&gt; --namespace &lt;ns&gt;</code><br><img src="/medias/1675238086770.jpeg"></li><li>运行： <code>lux suspend hr &lt;name&gt; -n &lt;ns&gt;</code></li><li>选择status=pending-upgrade的版本，运行： <code>helm uninstall &lt;name&gt; --namespace &lt;ns&gt; &lt;REVISION&gt;</code></li><li>运行： <code>flux resume helmrelease &lt;name&gt; -n &lt;ns&gt;</code></li></ol><p>搞定😊</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s PVC自动扩容实践</title>
      <link href="/2023/02/18/k8s-pvc-zi-dong-kuo-rong-shi-jian/"/>
      <url>/2023/02/18/k8s-pvc-zi-dong-kuo-rong-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>依赖:</p><ol><li>k8s &gt;= 1.24</li><li><a href="https://github.com/topolvm/pvc-autoresizer">pvc-autoresizer</a> &gt;= 0.5.0</li></ol><p>一、安装 pvc-autoresizer</p><ul><li><p>build  and push docker 镜像 <code>git clone https://github.com/topolvm/pvc-autoresizer &amp;&amp; git checkout v0.5.0 &amp;&amp; cd pvc-autoresizer &amp;&amp; docker build -t pvc-autoresizer:0.5.0 . &amp;&amp; docker push pvc-autoresizer:0.5.0</code></p></li><li><p>添加 helm repo: <code>helm repo add pvc-autoresizer https://topolvm.github.io/pvc-autoresizer/</code></p><span id="more"></span></li><li><p>values.yaml</p><pre class="line-numbers language-none"><code class="language-none"># config from https://github.com/topolvm/pvc-autoresizer/blob/main/charts/pvc-autoresizer/values.yamlimage:  # image.repository -- pvc-autoresizer image repository to use.  repository: perrorone/pvc-autoresizer  # image.tag -- pvc-autoresizer image tag to use.  # @default -- `{{ .Chart.AppVersion }}`  tag:  v0.5.0controller:  # controller.replicas -- Specify the number of replicas of the controller Pod.  replicas: 1  args:    # controller.args.prometheusURL -- Specify Prometheus URL to query volume stats.    # Used as "--prometheus-url" option    prometheusURL: &lt;you_prometheus_url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装 pvc-autoresizer: <code>helm install --create-namespace --namespace pvc-autoresizer pvc-autoresizer pvc-autoresizer/pvc-autoresizer --values ./values.yaml"</code></p></li><li><p>检查是否成功 <code>kubectl get pod -n pvc-autoresizer | grep pvc-autoresizer</code></p></li></ul><p>二、 创建StatefulSet以及存储类</p><ul><li>编写stateful-set.yaml:<pre class="line-numbers language-none"><code class="language-none">apiVersion: storage.k8s.io/v1kind: StorageClassmetadata:  name: test-pvc-autoresizer  namespace: staging  annotations:    resize.topolvm.io/enabled: "true" # 必须存在, 才能自动扩容parameters:  type: pd-ssdprovisioner: pd.csi.storage.gke.ioreclaimPolicy: RetainvolumeBindingMode: WaitForFirstConsumerallowVolumeExpansion: true---apiVersion: apps/v1kind: StatefulSetmetadata:  name: test-pvc-autoresizer  namespace: stagingspec:  selector:    matchLabels:      app: test-pvc-autoresizer  serviceName: "test-pvc-autoresizer"  replicas: 1  template:    metadata:      labels:        app: test-pvc-autoresizer    spec:      terminationGracePeriodSeconds: 10      containers:        - name: test-pvc-autoresizer          image: perrorone/go-file:v1.0.0          ports:            - containerPort: 80              name: http          livenessProbe:            httpGet:              path: /health              port: http          readinessProbe:            httpGet:              path: /health              port: http          volumeMounts:            - name: test-pvc-data              mountPath: /data          resources:            requests:              cpu: 200m              memory: 300Mi            limits:              cpu: 500m              memory: 500Mi  volumeClaimTemplates:    - metadata:        name: test-pvc-data        annotations:  # 必须存在, 使得自动创建的 PVC携带以下设置想才能自动扩容            resize.topolvm.io/storage_limit: 8Gi # 最大扩容大小            resize.topolvm.io/threshold: 20%      spec:        accessModes: [ "ReadWriteOnce" ]        storageClassName: "test-pvc-autoresizer"        resources:          requests:            storage: 1Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>部署: <code>kubectl apply -f ./stateful-set.yaml</code></li></ul><p>三、测试</p><ul><li><p>进入pod中检查挂载目录大小, <code>df -h</code> 输出可以看到<code>/data</code>目录只使用了1%空间</p></li><li><p>写入文件测试自动扩容: <code>dd if=/dev/zero of=1G.file bs=50M count=20</code></p></li><li><p>检查pvc-autoresizer pod 日志<br><img src="/medias/1666863168702.jpg"></p></li><li><p>再次检查pod挂载目录大小, 可以看见挂载目录已经使用了100%: <code>/dev/sdf                975.9M    959.9M         0 100% /data</code></p></li><li><p>等待一会,再次查看挂载目录大小, 可以看见已经扩容成功: <code>/dev/sdf                  1.9G    960.4M   1007.4M  49% /data</code> 😋😋😋😋😋😋<br><img src="/medias/1666863439959.jpg"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的一些小知识</title>
      <link href="/2023/02/18/redis-de-yi-xie-xiao-zhi-shi/"/>
      <url>/2023/02/18/redis-de-yi-xie-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="redis的数据类型使用场合？"><a href="#redis的数据类型使用场合？" class="headerlink" title="redis的数据类型使用场合？"></a>redis的数据类型使用场合？</h4><ul><li>string：其value可以储存string以及数字类型，一般用于复杂的技术功能上。</li><li>hash：其value存放的是结构化的对象，它可以能方便的去操作某个字段，我使用他实现过用户行为数据缓存以及session功能。</li><li>list：类似python中的list数据类型，我一般使用他做消息队列或者分页功能。</li><li>set：该数据结构储存的是一系列无序、不重复的数据，这个还提供差集、交集等等功能， 我使用它为爬虫去重以及用户阅读过的文章功能。</li><li>sorted sort：有序集合储存一系列有序，不重复的数据，大多数场景都使用他做一个榜单的功能。</li></ul><span id="more"></span><h4 id="redis的一些缺点"><a href="#redis的一些缺点" class="headerlink" title="redis的一些缺点"></a>redis的一些缺点</h4><ul><li>redis将所有数据放在内存中以便加快访问的速度，但是这也造成了redis容量受到物理内存大小的限制，所以redis对于一些海量数据场景有些乏力。</li><li>redis的在线扩容比较的麻烦，如果redis集群数量到达上限时，此时在线扩容是一个十分复杂的问题， 这大大提高了运维的成本。</li></ul><h4 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h4><ul><li>redis采用了定时删除 + 惰性删除的方式来删除过期的数据，这里的定时删除，redis并非将所有设置过期时间的key都遍历一遍， 如果这样做将会消耗大量的CPU资源。redis采用了随机抽样，如果被抽到的key过期了就删除，但是如果仅仅时这样，那么有可能一些数据永远不会被抽到，这时redis引入了惰性删除， 在访问KEY的时候检查一下是否过期，过期就删除。</li><li>如果redis仅仅采用上面两种方式来删除数据，那么在极端情况下仍然会有数据不会被删除。redis还有内存淘汰策略，我最长使用的是allkeys-lru， 当redis内存到达上限时， 他从所有key中寻找最近最少使用的KEY删除。</li></ul><h4 id="大量数据插入redis应该怎么做？"><a href="#大量数据插入redis应该怎么做？" class="headerlink" title="大量数据插入redis应该怎么做？"></a>大量数据插入redis应该怎么做？</h4><p>使用正常模式来插入显然不是一个明智的选择， 而使用管道的话某些客户端会被阻塞，导致不能在这期间执行其他的命令。比较好的方案是根据Redis协议生成一个文件，而后使用pipe mode去执行这个文件。参考<a href="https://redis.io/docs/reference/patterns/bulk-loading/">Redis Mass Insertion</a>。</p><h4 id="redis分区？"><a href="#redis分区？" class="headerlink" title="redis分区？"></a>redis分区？</h4><ul><li>redis的分区是指将数据分割成多个子集，分别保存到不同的redis实例中， 每一个redis实例都只保存了KEY的一个子集。</li><li>redis的分区在涉及多个key操作的时候，多数是不支持的，跟不要说多key事务操作。对于备份的情况也比较复杂。</li><li>redis分区有两种类型：<ol><li>按照范围分区， 映射一定范围的对象到特定的Redis实例，但是这种并不长使用。  </li><li>使用hash分区，其工作原理使用了hash表的原理，类似python dict。</li></ol></li></ul><h4 id="redis如何做集群？"><a href="#redis如何做集群？" class="headerlink" title="redis如何做集群？"></a>redis如何做集群？</h4><p>推荐使用官方的<a href="https://redis.io/docs/management/scaling/">redis cluster</a>,其实现原理是：redis集群内部有2 ** 14个哈希槽， 当需要插入key时， 首先对key使用<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81/10168758?fr=aladdin&amp;fromtitle=CRC%E6%A0%A1%E9%AA%8C&amp;fromid=3439037">crc16算法</a>计算出一个数字，在用此数字对2 ** 14 取余，该取余结果就是数据存放的哈希槽位置。而redis集群的节点管理这使用类似哨兵的机制来实现， 集群类节点通过相互ping来判断节点是否能够连接， 如果过半数节点都连接不上一个节点，则redis集群就会认定此节点宕机了。该方案确并不能保证数据的强一致性，所以在使用时一定不要将redis作为一个高可靠性的存储服务使用！</p><h4 id="redis时如何做持久化？"><a href="#redis时如何做持久化？" class="headerlink" title="redis时如何做持久化？"></a>redis时如何做持久化？</h4><p>redis支持两种持久化方案：   </p><ol><li>快照： 通过对配置文件的设置， 可以使得redis在N秒类M个key被修改时就将内存的数据以快照的方式写入到后缀为’.rdb’文件中。   </li><li>aof: 每一次收到一次写的命令就将此命令追加到后缀为’.aof’文件中， 当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cast类型转换库—go库推荐</title>
      <link href="/2023/02/18/cast-lei-xing-zhuan-huan-ku-go-ku-tui-jian/"/>
      <url>/2023/02/18/cast-lei-xing-zhuan-huan-ku-go-ku-tui-jian/</url>
      
        <content type="html"><![CDATA[<p>golang 中各种类型之间的转换实在是太过于繁琐，但是类型转换偏偏又是我们在开发过程中最常用的操作。同类型之间转换还稍微好一点，可以使用内置类型函数进行转换，但是想要转换不同的类型却需要引入不同的库， 而 cast 库正好解决了这一痛点，它提供了很多种的类型转换函数同我们使用， 通常的类型转换我们只需要引入这一个库就可以解决。</p><span id="more"></span><p>通常 go 中的类型转换都需要 err 变量来提示类型不可转换，cast 库提供了两种方法：</p><ol><li>仅返回该类型的零值，不会返回 err</li><li>使用函数 To__E 将会返回一个 err 变量来告诉我们是否发生错误这样分开提供函数，极大的方便我们在开发中根据当前所需选择函数。</li></ol><p>常用 API 列表：</p><ul><li><p>cast.StringToDate: 将常见的时间字符串转换为 time.Time 类型</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.StringToDate("2006-01-02 15:04:05")) // output: 2006-01-02 15:04:05 +0000 UTC &lt;nil&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>cast.ToBoolSlice: 将任意类型的数组转换为 []bool 类型</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToBoolSlice([]interface{}{1,2,0,true, false})) // output: [true true false true false]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>cast.ToBool: 将任意类型转换为 bool 类型</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToBool(1)) // output:truefmt.Println(cast.ToBool(0)) // output: falsefmt.Println(cast.ToBool("")) // output: falsefmt.Println(cast.ToBool("0")) // output: falsefmt.Println(cast.ToBool("1")) // output: truefmt.Println(cast.ToBool("true")) // output: truefmt.Println(cast.ToBool("false")) // output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>cast.ToString: 将任意类型转换成 string</p><pre class="line-numbers language-none"><code class="language-none">cast.ToString("mayonegg")         // "mayonegg"cast.ToString(8)                  // "8"cast.ToString(8.31)               // "8.31"cast.ToString([]byte("one time")) // "one time"cast.ToString(nil)        // "nil"var foo interface{} = "one more time"cast.ToString(foo)                // "one more time"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>cast.ToStringMap: 将任意类型 map 转换成 map[string]interface{}</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToStringMap(map[interface{}]interface{}{    1:2,    "2":3,    true:1,})) // output: map[1:2 2:3 true:1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的 API 可查看其文档：<a href="https://github.com/spf13/cast">https://github.com/spf13/cast</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis sds详解</title>
      <link href="/2023/02/18/sds-xiang-jie/"/>
      <url>/2023/02/18/sds-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是SDS？"><a href="#什么是SDS？" class="headerlink" title="什么是SDS？"></a>什么是SDS？</h3><p>SDS是redis构建的一种抽象类型，主要用于储存redis的默认字符串表示、AOF模块中的AOF缓冲区、客户端状态输入缓冲区。</p><span id="more"></span><h3 id="SDS有什么优点？"><a href="#SDS有什么优点？" class="headerlink" title="SDS有什么优点？"></a>SDS有什么优点？</h3><p>redis为什么不使用C的字符串？我们要先来看看C字符串中的缺点：</p><ol><li>C字符串不记录自身长度信息，为了获取字符串长度必须遍历整个字符串，时间复杂度为O(n)。</li><li>由于C字符串不记录自身长度，稍有不小心就会造成缓冲区溢出。</li><li>对于redis这种缓存类型数据库，对于缓存的Value是有可能经常的更改的。但是C字符串每次的增长或是缩小都需要一次内存的重分配操作。</li><li>redis数据库中缓存的内容不是特定的，有可能会是图片、音频等等文件的二进制数据，但是C字符串中的字符必须符合某种编码，且字符串中不能包含空格，这些限制也导致了redis不能使用C字符串来作为自身字符串的实现。 而SDS则将这些缺点都一一杜绝：<br>    1. SDS记录了自身的长度信息，使得获取字符串长度的时间复杂度为O(1)。<br>    2. SDS使用了预分配空间以及惰性空间释放的算法，解决了频繁分配内存的操作。<br>    3. SDS由于保存了自身的长度，也导致了SDS不会像C一样按照’\0’确定字符串的结尾。</li></ol><h3 id="SDS是如何实现的？"><a href="#SDS是如何实现的？" class="headerlink" title="SDS是如何实现的？"></a>SDS是如何实现的？</h3><p>redis使用名为sdshdr的结构体表示SDS值：</p><pre class="line-numbers language-none"><code class="language-none">struct sdshdr{int len; // 记录buf数组中已使用字节的数量int free; // 记录buf中未使用字节数量char buf[]; // 保存字符串的数组}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SDS遵循这C字符串以空字符结尾的惯例，以便能够重用C字符串中的函数，这个结尾的空字符串并不会增加len字段的值，例如现在需要使用SDS保存’golang’这个字符串，那么SDS对应的结构体是：<br><a href="https://imgtu.com/i/qNgzqI"><img src="https://s1.ax1x.com/2022/03/25/qNgzqI.png" alt="qNgzqI.png"></a></p><p>由于SDS记录了自身的长度，所以redis中获取字符串的长度只需要返回len字段的字段，其时间复杂度为O(1)，而对于C字符串经常发生的缓冲区溢出，SDS的空间分配策略完全杜绝了这种可能性：当redis需要对SDS字符串修改时，首先会检查SDS的空间是否满足修改所需的空间，如果不满足则将SDS空间扩容至满足该修改空间所需的容量，SDS空间扩容的算法如下：</p><pre><code>1. 如果SDS修改后的长度小于1MB，那么程序将会分配len字段值同样大小的未使用空间，这也是为什么我上面给出的例图中len的值是6，free值也是6的原因。对于上面那个例子，SDS的总占用大小为：6(len) + 6(free) + 1('\0’) = 13字节的容量。2.  如果SDS修改后的长度大于1MB，那么SDS将会为SDS分配1MB的未使用空间。如果一个SDS len值修改后的容量为2MB，那么redis将会为SDS分配1MB的未使用空间。则此时SDS的总占用大小为：2MB(len) + 1MB(len) + 1byte('\0’) =3073 byte容量。</code></pre><p>这种扩容算法，减少了频繁的向系统申请内存的操作。SDS的空间释放并不是实时的，而是惰性释放：redis认为如果一个SDS的容量到达过N大小，则极有可能在其缩小后也有可能到达N，且惰性释放也减少了下次内存分配的可能，假如现在有一个’golang’字符串存储在redis中， 现在我们需要将’golang’修改为’go’，那么redis将会对SDS结构体将会是这样的：<br><a href="https://imgtu.com/i/qN2RTP"><img src="https://s1.ax1x.com/2022/03/25/qN2RTP.png" alt="qN2RTP.png"></a><br><a href="https://imgtu.com/i/qN24fS"><img src="https://s1.ax1x.com/2022/03/25/qN24fS.png" alt="qN24fS.png"></a><br>SDS提供了清理内存的API，我们可以在有需要时，调用该API以便真正的释放内存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>redis只会使用C字符串作为字面量使用，大多数情况都使用SDS来表示字符串。</p></li><li><p>能够使用常数级复杂度获取字符串的长度。</p></li><li><p>杜绝了缓冲区溢出。</p></li><li><p>减少了字符串所需内存重新分配的次数。以及对于二进制数据安全，且兼容部分C字符串函数。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的channel详解</title>
      <link href="/2023/02/18/go-de-channel-xiang-jie/"/>
      <url>/2023/02/18/go-de-channel-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>此片文章基于<a href="https://studygolang.com/dl/golang/go1.12.1.src.tar.gz">golang 1.12.1</a>版本源码解析而成，chan源码位于go/src/runtime/chan.go文件中。</p><span id="more"></span><h3 id="channel是个什么？"><a href="#channel是个什么？" class="headerlink" title="channel是个什么？"></a>channel是个什么？</h3><p>chan 实际在源码中是一个结构体，该结构体结构如下：</p> <pre class="line-numbers language-none"><code class="language-none"> type hchan struct {qcount   uint           // 队列数据中的数据数量dataqsiz uint           // 循环队列的大小buf      unsafe.Pointer // 储存数据的元素数组elemsize uint16closed   uint32elemtype *_type // 元素类型sendx    uint   // 发送次数recvx    uint   // 接受次数recvq    waitq  // 当阻塞时，存放接受者的结构体sendq    waitq  // 当阻塞时，存放发送者者的结构体// 用于保证数据的并发安全lock mutex}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中sendx以及recvx为每次读取或者写入都需要将其加一，而recvq、sendq作用是有缓冲channel缓冲已满的情况下会将读取或是发送channel结构体放入其中。</p><h3 id="channel的创建"><a href="#channel的创建" class="headerlink" title="channel的创建"></a>channel的创建</h3><p>创建一个chan我们会使用make函数来创建， 实际make函数调用了makechan函数创建，该函数签名如下：func makechan(t *chantype, size int) *hchan ，t是chan接收或者发送的数据类型， size则是make函数的第二个参数，指明了chan的缓冲大小，默认为0即无缓冲chan,返回hchan结构体的指针。创建channel时首先会检测t的大小，如果t的大小超过了65536个字节的话，将会触发错误，在这里我们可以实验一下，创建一个类型，使得该类型在被创建时大小就超过65535字节：</p><pre class="line-numbers language-none"><code class="language-none">// 使用拼接字符串的方式去创建一个结构体， 该结构有65536 / intSize +1个int元素组成var d inta := "type A struct{\n"for i := 0; i&lt;= ((1&lt;&lt;16) / int(unsafe.Sizeof(d))) + 1; i++{a += fmt.Sprintf("\t\t\t\ta%d int\n", i)}a += "}"ioutil.WriteFile("./name.go", []byte(a), 07777)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体创建完成后，在main函数中尝试在chan中传递这种数据:_ = make(chan A)，此时该代码将会编译不通过并发出错误：’ channel element type too large (&gt;64kB)’。当chan传递的数据类型大小符合要求后，将会根据t类型的特征去创建一定容量大小的内存空间，并将此片内存空间复制给buf，直到此时一个channel就算创建hao了。值得一提的是chan包中提供了一个名称为debugChan的变量，该变量默认为False， 当他为True时， 对chan操作时将会打印一些debug信息， 这将会帮助我们快速的发现由于chan发生的BUG。</p><h3 id="向channel中发送数据"><a href="#向channel中发送数据" class="headerlink" title="向channel中发送数据"></a>向channel中发送数据</h3><p>向chan中发送数据由<a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#71">chan.go: 142</a> chansend函数实现。该函数首先会检查当前channel等于nil并且是一个有缓冲通道则直接返回，如果是一个无缓存通道则调用proc.gp:284 gopark将当前的goroutine设置为waiting状态。随后检测channel时候已经准备好发送数据了，如果已经可以发送数据，则调用chan.go:264 send函数发送数据，send的作用主要是将要发送的数据copy到buf中，如果当前channel是无缓冲的，则调用lock加锁，阻塞当前goroutine，当前数据被接受后，调用goready通知runtime当前goroutine已经准备好再次运行了。如果channel是有缓冲的， 则直接返回。</p><h3 id="从channel中接受数据"><a href="#从channel中接受数据" class="headerlink" title="从channel中接受数据"></a>从channel中接受数据</h3><p>接受数据实际跟发送数据流程是一样的，唯一不同的是当前channel是有缓冲的时候并且channel中没有数据被发送时， 则直接将接受chan数据的变量地址存入到sendq结构体中。当有发送数据时发现recvq中有数据时， 直接将数据存入到这个结构体中的地址中，而不再会使用buf去copy数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>channel使用copy buf的方式来通信， 最后实现以通信的方式来共享内存。当一个goroutine阻塞的时候，系统线程会把它放入到hchan.sendq或者hchan.recvq list中， 该list中的sudog类型的结构题就是当前goruntine， 而这个sudog结构体中保存着一个变量，该变量保存着channel相关的指针。之前使用chan仅仅只是会使用，而不知其原理， 看了其源码，之前不理解的地方也恍然大悟。写这篇文章时是对着源码写的，可能有一些顺序上的矛盾。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python IO多路复用实践</title>
      <link href="/2023/02/18/io-duo-lu-fu-yong-shi-jian/"/>
      <url>/2023/02/18/io-duo-lu-fu-yong-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>最近几天一直在看tornado源码，发现torando虽然标榜使用异步模型实现， 但是实际上是使用IO多路复用实现的事件循环，为了能对 IO多路复用加深印象，决定自己实现一个简易的HTTP客户端对比一下同步客户端和IO多路复用客户端的性能差别。</p><span id="more"></span><p>废话少说， 现在先来看看同步客户端与IO多路复用客户端最直观的区别，首先使用tornado实现一个简单的服务端:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> tornado<span class="token punctuation">.</span>web <span class="token keyword">import</span> RequestHandler<span class="token punctuation">,</span> Application<span class="token keyword">from</span> tornado<span class="token punctuation">.</span>ioloop <span class="token keyword">import</span> IOLoop<span class="token keyword">import</span> tornado<span class="token punctuation">.</span>gen<span class="token keyword">class</span> <span class="token class-name">TestHandle</span><span class="token punctuation">(</span>RequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">await</span> tornado<span class="token punctuation">.</span>gen<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app <span class="token operator">=</span> Application<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> TestHandle<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span>    IOLoop<span class="token punctuation">.</span>current<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们让服务端在处理请求时暂停1秒，以便能够更方便观察出两种方式实现的客户端区别，接下来先实现同步客户端:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> timeREQUEST_STR <span class="token operator">=</span> <span class="token string">'{method} {path} HTTP/1.0\r\n\r\n'</span><span class="token keyword">def</span> <span class="token function">block_client</span><span class="token punctuation">(</span>hostname<span class="token punctuation">,</span> port<span class="token punctuation">,</span> method<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>    sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>hostname<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>REQUEST_STR<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>method<span class="token operator">=</span>method<span class="token punctuation">,</span> path<span class="token operator">=</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    response_body <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        response_stream <span class="token operator">=</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> response_stream<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">b""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>response_body<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>        response_body<span class="token punctuation">.</span>append<span class="token punctuation">(</span>response_stream<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">3</span>    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        block_client<span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8080</span><span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">"GET"</span><span class="token punctuation">,</span> path<span class="token operator">=</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{} 请求{}次, 运行时间: {:.1f}秒"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>block_client<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> count<span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动服务端， 开始测试同步客户端请求服务端需要多少时间:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; C:\Users\Administrator&gt;python client.pyblock_client 请求3次, 运行时间: 3.0秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不出所料，请求三次由于服务器暂停了1秒总计使用时间为3秒。接下来实现IO多路复用客户端，来看看IO多路复用的表现:</p><pre class="line-numbers language-none"><code class="language-none">from selectors import DefaultSelector, EVENT_WRITE, EVENT_READimport socketimport timeREQUEST_STR = '{method} {path} HTTP/1.0\r\n\r\n'JOBS_COUNT = 0select = DefaultSelector()class NoBlockClient:    def __init__(self):        self.result = []    def request(self, method, hostname, port, path):        global JOBS_COUNT        JOBS_COUNT += 1        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        sock.setblocking(False)        try:            sock.connect((hostname, port))        except BlockingIOError:            pass        select.register(sock.fileno(), EVENT_WRITE, partial(self._send, sock, method, path))    def _send(self, sock, method, path):        select.unregister(sock.fileno())        sock.send(REQUEST_STR.format(method=method, path=path).encode())        select.register(sock.fileno(), EVENT_READ, partial(self._recv, sock))    def _recv(self, sock):        global JOBS_COUNT        response_stream = sock.recv(1024)        if not response_stream:            select.unregister(sock.fileno())            sock.close()            JOBS_COUNT -= 1        else:            self.result.append(response_stream)    def run(self):        while JOBS_COUNT:            events = select.select()            for key, mask in events:                callback = key.data                callback()        return self.resultstart_time = time.time()count = 3no_block_client = NoBlockClient()for _ in range(count):    no_block_client.request("GET", "127.0.0.1", 8080, "/")result = no_block_client.run()print("{} 请求{}次, 运行时间: {:.1f}秒".format(NoBlockClient.__name__, count, time.time() - start_time))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行客户端:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;C:\Users\Administrator&gt;python no_block_client.pyNoBlockClient 请求3次, 运行时间: 1.0秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>非常明显的看见时间上的区别，虽然代码看起来特别的复杂， 但是说的直白一点就是将每一个函数对应一个事件注册进sleelct中， 由sleect进行监控， 如果有事件触发就运行对应的函数。</p><p>我们分析下IO多路复用客户端代码：</p><ol><li>select = DefaultSelector() 该行代码返回了当前平台IO多路复用最佳实现方式，分别为：select、poll、epoll、dev/poll、kqueue, 由于我是使用win来测试所以DefaultSelector() 返回了select模型。</li><li>NoBlockClient.request 函数目的是创建一个非阻塞套接字连接至目标服务器， 并将当前套接字注册进select中， 当其状态为可写时， 运行NoBlockClient._send ，相当于一个回调函数。</li><li>NoBlockClient._send 负责将消息发送至已连接的服务器，最后如同NoBlockClient.request 一样注册事件选择回调函数。</li><li>NoBlockClient._recv 当注册事件为可读时， 将运行该函数， 读取服务器返回数据，至此一次完整的请求就结束了。</li><li>NoBlockClient.run 函数主要为了让select开始循环监听这些注册事件的状态，并运行回调函数。</li></ol><p>selectors模块是对select模块封装，使得我们不用在意当前平台需要使用什么模型，而是直接返回当前平台最佳的模型，并将各个模型的api进行整合，让使用者能够更方便的写出跨平台代码。 最经常使用的几种模型包括: select,、poll、 epoll，接下来所以说这几种模型的区别，优缺点以及大概的实现方式。</p><ol><li><p>select: select将被注册的事件放入一个列表中并拷贝到内核空间进行监听，如果这些事件其中一个有了变化那么select将再次把包含事件的列表拷贝进用户空间，这就造成了资源上的极大浪费， 如果select只监听一个或者两个事件还好， 但是当select需要监听的事件越来越多时，select的性能将会直线下降。而且select将时间拷贝到用户空间时并不会告诉用户哪一个事件被触发了，而是要用户自己去遍历。因为select监听的事件越多性能越差所以通常系统内核都会对select模型监听数量进行限制，在python源码中(<a href="https://github.com/python/cpython/blob/master/Modules/selectmodule.c">github: selectmodule.c</a>) 使用宏定义将win中select监听事件限制在了512, 当然select的最大优点则是几乎所有的平台都支持select。</p></li><li><p>poll: 其实现方式几乎与select相同， 所以select有的缺点poll也拥有，这里就不多说了。详情见<a href="https://blog.csdn.net/luojian5900339/article/details/54581852">poll事件机制</a>。</p></li><li><p>epoll: epoll相比较select、poll有了质的改变，epoll将注册的事件都插入到了红黑树中，红黑树中的每一个节点都是一个注册的事件， 由于红黑树查询、插入、删除时间复杂度都是O(logn)，所以 epoll能够更加方便的对事件进行管理， 并且其在事件被触发时仅仅返回被触发的事件而不是像select全部返回， 这大大增加了效率。更加详细的epoll模型介绍见<a href="https://blog.csdn.net/apacat/article/details/51375950">EPOLL的理解和深入分析</a>。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python dict</title>
      <link href="/2023/02/18/dict/"/>
      <url>/2023/02/18/dict/</url>
      
        <content type="html"><![CDATA[<p>python的dict是一种映射类型, 底层使用了哈希表的方式来储存数据, 因此dict的查询速度的时间复杂度为O(1),这是一种典型的空间换时间的数据结构。</p><p>当我们创建一个key-value时，首先将哈希函数作用于key上获得一个整型数组，将这个整型数字与储存value数组的长度取余， 得到该数组的下标， 该下标就是value所存放的位置。 python在初始化dict时首先会申请一个大小为8KB左右的数组用来存放value（见dictobject.c第111行定义字典最小容量） ，如果数组位置不够存放则会再向系统申请两倍于当前容量的数组来存放value。</p><p>对于哈希冲突python选择了开放寻址法来解决：当产生哈希冲突时，通过探测函数计算出下一个候选位置，如果下一个候选位置还是有冲突，那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。</p><p>dict的初始化在<a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c#L691">dictobject.PyDict_New:691</a>该函数中完成：</p><pre class="line-numbers language-none"><code class="language-none">PyObject * PyDict_New(void){dictkeys_incref(Py_EMPTY_KEYS);return new_dict(Py_EMPTY_KEYS, empty_values);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在python3.6之后dict的键的顺序保持了插入时的顺序 <a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c#L13">dictobject.c:13</a></p><pre class="line-numbers language-none"><code class="language-none">As of Python 3.6, this is compact and ordered. Basic idea is described here:* https://mail.python.org/pipermail/python-dev/2012-December/123028.html* https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python深拷贝浅拷贝</title>
      <link href="/2023/02/18/python-shen-kao-bei-qian-kao-bei/"/>
      <url>/2023/02/18/python-shen-kao-bei-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<p>说到python中的对象拷贝问题，还得看看is和==的区别：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; b = [1,2,3,4]&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bFalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看见a和b中的数值都是一样的，但是与is的结果却不是一样的，这是因为python中比较的是a和b的数值相等，is比较对象的标识是否相等。所以在python中我们经常会使用==来比较对象的数值时候相等， 判断对象绑定的值时候是None, 最好使用is。这里面有一个坑，一些新手经常犯的错误，空字符串，空列表，空字典，他们的都等于False，但是他们都不是（不等于）None,所以在判断一个字符串，列表，字典是否为空时， 不要用None来做比较,因为这些变量无论是从对象标识，数值都与None不相等。   我们平常是用的对象复制一般都是浅拷贝。copy模块为我们提供了copy(浅拷贝)，deepcopy(深拷贝）函数,</p><p>什么是浅拷贝：<br>浅拷贝就是将拷贝的对象引用拷贝一份，拷贝对象指向的是被拷贝对象的数值，简单的说就是，在原有数值上面再添加的一份引用。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a =1&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)4297636352&gt;&gt;&gt; id(b)4297636352<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>什么是深拷贝：<br>深拷贝就是拷贝对象对被拷贝对象数值上复制一份，然后新建一个对象，这个新的对象数值，对象标识都是和被拷贝对象相等的.</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; b[1,2,3]&gt;&gt;&gt; a[1,2,3]&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; id(a)4297636352&gt;&gt;&gt; id(b)4297636352&gt;&gt;&gt; a.append(0)&gt;&gt;&gt; a[1,2,3,0]&gt;&gt;&gt; b[1,2,3]&gt;&gt;&gt; b.append(9)&gt;&gt;&gt; b[1, 2, 3, 9]&gt;&gt;&gt; a[1, 2, 3, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于这种现象，所以我们应该特别注意函数在使用可变参数作为默认参数，如不注意就会出现下面这种情况：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def a(x = []):... x.append(0)... print(x)&gt;&gt;&gt; a()[0]&gt;&gt;&gt; a()[0, 0]&gt;&gt;&gt; a()[0, 0, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种情况我们应该避免使用可变对象作为函数默认参数：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def a(x = None):...     if x is None:...             x = []...     else:...             x.append(0)...     print(x)...&gt;&gt;&gt; a()[]&gt;&gt;&gt; a()[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时创建类初始化传参也是使用浅拷贝来传递的，这样就会出现这种情况：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; class A:...     def __init__(self, name):...         self.name = name...     def printf(self):...         print(self.name)...&gt;&gt;&gt; x = [1,2,3,4]&gt;&gt;&gt; a = A(x)&gt;&gt;&gt; a.printf()[1, 2, 3, 4]&gt;&gt;&gt; x.append(5)&gt;&gt;&gt; a.printf()[1, 2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在传入的参数改变的时候，类里面的变量的值页跟着改变了，这种情况时最难发现的。深拷贝/浅拷贝他们最大的区别就是:深拷贝拷贝父级对象及其子对象; 浅拷贝只拷贝父级对象.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端传给前端int 类型数据自增或自减</title>
      <link href="/2018/03/16/hou-duan-chuan-gei-qian-duan-int-lei-xing-shu-ju-zi-zeng-huo-zi-jian/"/>
      <url>/2018/03/16/hou-duan-chuan-gei-qian-duan-int-lei-xing-shu-ju-zi-zeng-huo-zi-jian/</url>
      
        <content type="html"><![CDATA[<p>由于我使用的python3 ,在python中int 类型不像其他语言的int类型， python 将long类型也加入到了int中， 所以再python中能够正确显示的int类型在其他的语言中不一定能够正确的显示， 当python 传的int 超过了浏览器所能解析的最大值时就会出现这种情况， 建议将较大的int 类型转换成string 在传给前端。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python内置函数</title>
      <link href="/2017/12/15/python-nei-zhi-han-shu/"/>
      <url>/2017/12/15/python-nei-zhi-han-shu/</url>
      
        <content type="html"><![CDATA[<p>abs(x): 接受一个整数或浮点数作为参数，返回该参数的绝对值，如果该参数是一个复数，则返回复数的模。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(4 - 8j)8.94427190999916<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>all(iter): 接受一个可迭代类型，如果该参数内所有元素为真返回True，否则返回False。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; all([1,2,3,4,5])True&gt;&gt;&gt; all([1,2,3,4,0])False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>any(iter):接受一个可迭代类型为参数,如果该参数内任何元素为真,则返回True,否则返回False.</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; any([0, 0,1])True&gt;&gt;&gt; any([0, 0,0])False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>asicc(object):接受一个对象, 将调用该对象的__repr__方法, 返回的字符串会将\x,\u,\U进行转移输出.</p><pre class="line-numbers language-none"><code class="language-none">In [4]: class a:...:     def __repr__(self):...:         return "repr"In [5]: ascii(a())Out[5]: 'repr'In [9]: ascii("\n\rfdsafdsa")Out[9]: "'\\n\\rfdsafdsa'"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bin(x):接受一个整数作为参数, 并将该参数转换成以”0b”前缀的二进制字符串,如果x不是一个整数,那么将会调用对象的__index__方法的整数并转换成二进制.</p><pre class="line-numbers language-none"><code class="language-none">In [15]: class a:...:     def __index__(self):...:         return 1In [14]: bin(1)Out[14]: '0b1'In [16]: bin(a())Out[16]: '0b1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bool([x]):如果不传参数,则默认返回Fase,如果X是一个不是整数或浮点数则首先调用对象的__bool__方法, 如果对象的__bool__方法未定义,其次调用__len__方法,如果返回0则bool()返回False,否则返回True,如果对象__len__、__bool__方法都未定义则默认返回True</p><pre class="line-numbers language-none"><code class="language-none">In [39]: bool(1)Out[39]: TrueIn [40]: bool(0.0)Out[40]: FalseIn [41]: bool(0 - 0j)Out[41]: FalseIn [43]: class a:...:     def __bool__(self): return True...:     def __len__(self): return 0In [45]: bool(a())Out[45]: TrueIn [44]: bool(a)Out[44]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytearray([source[, encoding[, errors]]]):接受一个大于等于0小于256的整数或者一个可迭代类型、如果参数一个字符串,那么必须指定encoding. 返回一个新的字节数组.如果传入一个对象首先调用该对象__index__, 如果未定义__index__则调用对象__iter__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [64]: class a:...:     def __iter__(self):...:         for i in range(0, 256):...:             yield i...:     def __index__(self): return 1...:In [65]: bytearray(a())Out[65]: bytearray(b'\x00')In [48]: bytearray()Out[48]: bytearray(b'')In [49]: bytearray([1,2,3,4,5,6,7])Out[49]: bytearray(b'\x01\x02\x03\x04\x05\x06\x07')In [77]: bytearray(1)Out[77]: bytearray(b'\x00')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytes([source[, encoding[, errors]]]): 如同bytearray使用方法, 不过该函数返回的一个不可变类型.</p><pre class="line-numbers language-none"><code class="language-none">In [72]: class a:...:     def __iter__(self):...:         for i in range(0, 256):...:             yield i...:     def __index__(self): return 1...:In [73]: bytes(a())Out[73]: b'\x00'In [79]: bytes(1)Out[79]: b'\x00'In [80]: bytes()Out[80]: b''In [81]: bytes([1,2,3,4,5,6,7])Out[81]: b'\x01\x02\x03\x04\x05\x06\x07'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>callable(object):接受一个对象作为参数, 如果该参数是可以调用的则返回True, 否则返回False</p><pre class="line-numbers language-none"><code class="language-none">In [83]: class a:passIn [85]: callable(a)Out[85]: TrueIn [86]: callable(a())Out[86]: FalseIn [88]: class a:...:     def __call__(self):...:         return 1In [89]: callable(a())Out[89]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>chr(i): 接受一个整数, 返回该整数对应的Unicode代码点的字符串,该整数必须大于等于0,小于等于1114112.</p><pre class="line-numbers language-none"><code class="language-none">In [105]: chr(0)Out[105]: '\x00'In [99]: chr(1114111)Out[99]: '\U0010ffff'In [100]: chr(1114112) # 超出范围---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-100-4857faf08086&gt; in &lt;module&gt;----&gt; 1 chr(1114112)ValueError: chr() arg not in range(0x110000)==<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@classmethod:装饰器, 作用于类方法上, 被装饰的方法将转换成类方法,类方法的一个参数将是类本身.</p><pre class="line-numbers language-none"><code class="language-none">In [110]: class a:...:     def a1(self):...:         print(self)...:     @classmethod...:     def a2(self): # 按照约定应该将self修改成cls来从字面量上区分类方法和实例方法....:         print(self)...:In [111]: a().a1() # 实例方法&lt;__main__.a object at 0x00000245CBE815C0&gt;In [112]: a.a2() # 类方法&lt;class '__main__.a'&gt;In [113]: a().a2() # 实例可以调用类方法&lt;class '__main__.a'&gt;In [115]: a.a1() # 类在未实例化之前不能调用实例化方法, 当然有捷径可以走,这里只是做了一个区分, 不展示捷径---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-115-2656506098d9&gt; in &lt;module&gt;----&gt; 1 a.a1()TypeError: a1() missing 1 required positional argument: 'self'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):将一个字符串编译成字节代码:</p><pre class="line-numbers language-none"><code class="language-none">source: 字符串或者AST对象,filename: 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值, 如’’.mode: 指定编译代码的种类。可以指定为 exec, eval, singleflags: 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。flags和dont_inherit是用来控制编译源码时的标志In [121]: d = compile("print(1)", "", "exec")In [122]: dOut[122]: &lt;code object &lt;module&gt; at 0x00000245CBF448A0, file "", line 1&gt;In [123]: exec(d)1complex([real[, imag]]): 创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In [125]: complex(1, 2)<br>Out[125]: (1+2j)<br>In [127]: complex(“1”)<br>Out[127]: (1+0j)<br>In [128]: complex(“1+2j”) # 此处不能有空格, 否则会报错<br>Out[128]: (1+2j)<br>delattr(object, name): 接受一个对象以及一个字符串,删除该对象的name属性,也可以使用del object.name来实现.</p><pre class="line-numbers language-none"><code class="language-none">In [144]: class a:...:     x = 1...:     y = 2...:In [145]: delattr(a, "x")In [147]: a.x---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-147-e27186f28a17&gt; in &lt;module&gt;----&gt; 1 a.xAttributeError: type object 'a' has no attribute 'x'In [148]: a.yOut[148]: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dict([object]):用于创建一个字典.如果不传参数,则返回一个空的字典.</p><pre class="line-numbers language-none"><code class="language-none">In [150]: dict()Out[150]: {}In [151]: dict(a=1, b=2)Out[151]: {'a': 1, 'b': 2}In [152]: dict({"a":1})Out[152]: {'a': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dir([object]):不传参数时, 返回当前范围内变量、方法和定义的类型列表,传入参数时返回该参数的所有的属性、方法, 如果该参数定义了__dir__方法, 则使用__dir__返回值, 否则该函数将尽可能的最大限度的收集该对象的方法以及属性.</p><pre class="line-numbers language-none"><code class="language-none">In [157]: dir("")Out[157]:['__add__','__class__','__contains__',...]In [155]: class a:...:     def __dir__(self):...:         return ["a", "b"]...:In [156]: dir(a())Out[156]: ['a', 'b']In [158]: class a:...:     x = 1...:     y = 2...:In [159]: dir(a)[...,'x','y']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>divmod(x, y): 接受两个非复数的数字作为参数, 返回X,Y的商和余.</p><pre class="line-numbers language-none"><code class="language-none">In [160]: divmod(1, 2)Out[160]: (0, 1)In [161]: divmod(1.5, 2)Out[161]: (0.0, 1.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>enumerate(iterable, start=0):接受一个可迭代类型以及一个可选int类型的参数, 返回一个枚举对象.如果指定了start则该可迭代对象的下边从start开始.</p><pre class="line-numbers language-none"><code class="language-none">In [163]: enumerate([1,2,3,4])Out[163]: &lt;enumerate at 0x245cbf50438&gt;In [164]: list(enumerate([1,2,3,4]))Out[164]: [(0, 1), (1, 2), (2, 3), (3, 4)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>eval(expression, globals=None, locals=None):接受一个字符串类型的表达式, 并执行该表达式,返回其值.</p><pre class="line-numbers language-none"><code class="language-none">expression: 字符串类型的表达式.globals: 字典类型, 变量作用域，全局命名空间.locals: 任何的映射对象, 变量作用域，局部命名空间.In [166]: eval("1 + 2")Out[166]: 3exec(object[, globals[, locals]]):该函数提供动态执行python代码的功能,object可以是字符串也可以是一个代码对象. globals必须是一个字典,locals则可以是任何的映射对象,In [168]: x = 1In [169]: exec("x + 2")In [172]: xOut[172]: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>filter(function,iterable):接受一个函数对象以及一个可迭代对象作为参数, 将可迭代对象中的每一个元素传入第一个参数中,如果该函数返回True则保留当前元素,否则删除当前元素.filter函数返回一个可迭代对象.</p><pre class="line-numbers language-none"><code class="language-none">In [3]: list(filter(lambda x: False, [1,2,3,4]))Out[3]: []In [4]: list(filter(lambda x: True, [1,2,3,4]))Out[4]: [1, 2, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>float([x]): 接受一个可选整型、浮点型、对象或者字符串类型参数, 返回该参数的浮点类型数据,如果X是一个自定义对象那么将调用对象的__float__方法(仅提供用方法, 完整方法见:float).</p><pre class="line-numbers language-none"><code class="language-none">In [6]: float("+1")Out[6]: 1.0In [7]: float("-1")Out[7]: -1.0In [8]: float("Inf")Out[8]: infIn [11]: float(1)Out[11]: 1.0In [12]: float(1.2)Out[12]: 1.2# 自定义对象In [14]: class a:...:     def __float__(self): return 1.0...:In [15]: float(a())Out[15]: 1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>format(value[,format_spec]):格式化字符串函数, 接受不限个参数，位置可以不按顺序, 其数字格式化符号见菜鸟教程, 对于自定义对象, 则调用对象的__format__方法, 如果对象没有定义__format__则使用对象__str__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [20]: "{}|{}".format(1, "dsa")Out[20]: '1|dsa'In [21]: "{1}|{0}".format(1, "dsa")Out[21]: 'dsa|1'In [22]: "{0}|{1}".format(1, "dsa")Out[22]: '1|dsa'In [23]: "{:.2f}".format(1.235646)Out[23]: '1.24'In [33]: class a:...:     def __format__(self, *args):...:         return "format"...:In [34]: "{}".format(a())Out[34]: 'format'In [36]: class a:...:     def __str__(self):...:         return "str"...:In [37]: "{}".format(a())Out[37]: 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>frozenset([iterable]): 接受一个可选的可迭代类型的参数, 返回一个frozenset对象, 该对象与set对象基本相似, 但是该对象是不可变的.</p><pre class="line-numbers language-none"><code class="language-none">In [39]: frozenset()Out[39]: frozenset()In [40]: frozenset([1,2,1,1])Out[40]: frozenset({1, 2})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getattr(object,name[,default]): 接受两个必选参数和一个可选参数, 该函数返回了object.name的值, 如果不存在name属性,并且没有传入default参数时则触发异常, 如果传入了default参数则没有找到name属性时返回default.</p><pre class="line-numbers language-none"><code class="language-none">In [45]: class a:...:     def b(self):...:         return "2"In [47]: getattr(a(), "b")()Out[47]: '2'getattr(a(), "b1", lambda : print("b1"))()b1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>globals(): 返回当前所有全局变量的字典.</p><pre class="line-numbers language-none"><code class="language-none">In [49]: globals()Out[49]:{'__name__': '__main__','__doc__': 'Automatically created module for IPython interactive environment','__package__': None,...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hasattr(object, name): 接受两个必选参数, 检测object中是否有那么属性.如果有name属性返回True,否则返回False.</p><pre class="line-numbers language-none"><code class="language-none">In [50]: class a:...:     b = 1...:In [51]: hasattr(a, "b")Out[51]: TrueIn [52]: hasattr(a, "b1")Out[52]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hash(object): 接受一个必选参数, 返回该对象的整型哈希值, 如果时自定义对象则调用对象的__hash__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [56]: hash("fdsaf")Out[56]: 2111967917974353823In [58]: class a:...:     def __hash__(self):...:         return 9527...:In [59]: hash(a())Out[59]: 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>help([object]): 接受一个可选的参数, 该参数可以是任意的类型, 返回该对象的帮助文档, 如果是自定义对象, 则返回该函数或者类的注释.如果没有传入参数则拉起交互式的帮助系统</p><pre class="line-numbers language-none"><code class="language-none">In [62]: help(1)Help on int object:class int(object)|  int(x=0) -&gt; integer...In [65]: class a:...:     """这是help信息"""...:     def b(self):...:         """这也是help信息"""...:         passIn [66]: help(a())Help on a in module __main__ object:class a(builtins.object)|  这是help信息||  Methods defined here:||  b(self)|      这也是help信息||  ----------------------------------------------------------------------|  Data descriptors defined here:||  __dict__|      dictionary for instance variables (if defined)||  __weakref__|      list of weak references to the object (if defined)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hex(x):接受一个整型作为必选参数, 返回该参数的16进制字符串, 该字符串以0x开头,如果x是一个自定义对象那么该对象必须实现__index__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [72]: hex(185)Out[72]: '0xb9'In [74]: class a:...:     def __index__(self): return 1In [75]: hex(a())Out[75]: '0x1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>id(object): 返回该对象在内存中的地址以整型返回.</p><pre class="line-numbers language-none"><code class="language-none">In [77]: id(1)Out[77]: 1786755536In [81]: class a:...:     def __init__(self, x):...:         self.x = x...:In [82]: id(a(1)) == id(2)Out[82]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>input([prompt]): 从标准输入中读取输入一回车键结束, 如果传入prompt, 则将prompt打印到标准输出中.</p><pre class="line-numbers language-none"><code class="language-none">In [84]: input("这是提示:")这是提示:ddOut[84]: 'dd'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>int(x, base=10):将一个字符串或数字转换为整型,如果没有传入参数则返回0,如果传入传入了base则表示X是base进制的数字.如果X是一个自定义对象, 则调用__init__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [86]: int()Out[86]: 0In [87]: int(1.0)Out[87]: 1In [90]: int("0x9b", 16)Out[90]: 155In [91]: class a:...:     def __int__(self):...:         return 1In [92]: int(a())Out[92]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>isinstance(object, classinfo):如果object是classinfo的实例或者子类的实例, 返回True, 否则返回False.如果classinfo是一个元组, 那么object只要是元组中任意一个元素的子类的实例或者实例化都返回True.</p><pre class="line-numbers language-none"><code class="language-none">In [94]: class a: passIn [95]: class b(a): passIn [99]: isinstance(b(), a)Out[99]: TrueIn [101]: isinstance(1, int)Out[101]: TrueIn [103]: isinstance(1, str)Out[103]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>issubclass(class, classinfo):如果class是classinfo的子类返回true, 使用方法与isinstance相同.</p><pre class="line-numbers language-none"><code class="language-none">In [94]: class a: passIn [95]: class b(a): passIn [105]: issubclass(b, a)Out[105]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>iter(object[,sentinel]):返回一个迭代器对象, 如果没有传入第二个参数, 那么object必须是实现了迭代协议或者序列协议否则将触发TypeError, 如果传入了sentinel参数那么object必须是可调用对象, 此时每迭代一次都调用object,如果object返回的值等于sentinel时,触发StopIteration异常.</p><pre class="line-numbers language-none"><code class="language-none">In [108]: iter([1,2,3])Out[108]: &lt;list_iterator at 0x210bde35f98&gt;In [110]: class a:...:     def __iter__(self):...:         for i in range(10):...:             yield i...:In [111]: list(iter(a()))Out[111]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [12]: def a():...:     global num...:     num += 1...:     if num &gt;= 10:...:         return -1...:     return numIn [13]: for i in iter(a, -1):...:     print(i)123456789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>len(s): 接受一个序列或者集合类型对象, 返回其长度, 如果时自定义对象, 将会调用对象的__len__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [18]: len([1,2,3])Out[18]: 3In [19]: len({1:2, 3:4})Out[19]: 2In [20]: class a:...:     def __len__(self): return 1In [21]: len(a())Out[21]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>locals():返回当前本地和只有变量的值.</p><pre class="line-numbers language-none"><code class="language-none">In [24]: def a():...:     x = 1...:     print(locals())In [25]: a(){'x': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>map(function,iterable…):返回一个迭代器, 该函数将function应用与每一个iterable元素上并返回直到可迭代对象耗尽.</p><pre class="line-numbers language-none"><code class="language-none">In [27]: map(lambda x: x ** 2, [1,2,3])Out[27]: &lt;map at 0x2aec3ae4a20&gt;In [28]: list(map(lambda x: x ** 2, [1,2,3]))Out[28]: [1, 4, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>max(arg1,arg2,*args[,key]):接受多个位置参数或者一个可迭代对象, 返回其中最大的值.</p><pre class="line-numbers language-none"><code class="language-none">In [39]: max(1,2)Out[39]: 2In [40]: max([2,3,4,5])Out[40]: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>memoryview(obj): 返回obj的内存查看对象(对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问).</p><pre class="line-numbers language-none"><code class="language-none">In [43]: a = b"dsadsad"In [44]: d = memoryview(a)In [47]: d[0]Out[47]: 10# 未复制数据In [52]: id(d.obj)Out[52]: 2949631565952In [53]: id(a)Out[53]: 2949631565952<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>min(arg1，arg2，* args[，key]): 接受多个位置参数或者一个可迭代对象, 返回其中最小的值.</p><pre class="line-numbers language-none"><code class="language-none">In [55]: min(1,2)Out[55]: 1In [56]: min([1,2,3,5])Out[56]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>next(iterator[,default]): 通过调用iterator的__next__方法并返回其值.</p><pre class="line-numbers language-none"><code class="language-none">In [58]: class a:...:     def __next__(self):...:         for i in range(10):...:             yield iIn [60]: list(next(a()))Out[60]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>object(): 返回一个新的无任何特征的对象, object时所有class的基类.</p><pre class="line-numbers language-none"><code class="language-none">In [105]: object()Out[105]: &lt;object at 0x2aec3a34880&gt;In [106]: class a:passIn [107]: issubclass(a, object)Out[107]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>oct(x):接受一个整型作为参数返回以”0o”为前缀的八进制字符串,如果x是自定义对象, 则调用该对象的__index__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [109]: oct(1)Out[109]: '0o1'In [111]: class a:...:     def __index__(self): return 1In [112]: oct(a())Out[112]: '0o1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>open(file,mode=’r’,buffering=-1,encoding=None,errors=None,newline=None,<br>closefd=True,opener=None):打开file文件并返回一个文件对象, 具体参数值见open.</p><pre class="line-numbers language-none"><code class="language-none">file: 文件所在的路径以及文件名mode: 打开文件的模式, 默认"r”buffering: 用于设置缓冲策略, 0为关闭缓冲, 1为选择行缓冲, &gt; 1以指示固定大小的块缓存区.默认-1,二进制文件以固定大小的块缓冲 4.encoding:用于解码或编码文件的编码的名称, 默认编码取决于所在的操作系统 5.errors:指定如何处理编码和解码错误, 仅能在文本模式下使用 6.newline: 控制通用换行模式的工作方式（仅适用于文本模式）。它可以是None，''，'\n’，'\r’，和’\r\n’In [114]: open("test.test", "w").write("fdsa")Out[114]: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ord(c): 接受一个字符串类型参数, 返回该Unicode代码点的整数.</p><pre class="line-numbers language-none"><code class="language-none">In [116]: ord("a")Out[116]: 97In [117]: ord("你")Out[117]: 20320<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pow(x,y[,z]):当未传入Z参数时,返回x的y次方,如果传入了Z则对结果取余.</p><pre class="line-numbers language-none"><code class="language-none">In [122]: pow(2,3)Out[122]: 8In [124]: pow(2,3, 2)Out[124]: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>print(*objects,sep=’ ‘,end=’\n’,file=sys.stdout,flush=False):将objects对象打印到标准输出中,每一个objects使用sep分割, 以end结束,对于自定义对象, 首先调用对象__str__方法, 如果没有定义__str__方法则调用__repr__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [136]: class a:...:     def __str__(self): return "str"...:     def __repr__(self): return "repr"In [137]: print(a())str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>property(fget=None，fset=None，fdel=None，doc=None): 可作为装饰器使用也可作为函数使用.用于显示类属性的读取、设置以及删除. 作为函数使用时:</p><pre class="line-numbers language-none"><code class="language-none">In [140]: class a:...:     def __init__(self):...:         self._x = None...:...:     def getx(self):...:         return self._x...:...:     def setx(self, x):...:         self._x = x...:     def delx(self):...:         self._x = None...:     x = property(getx, setx, delx, "test")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为装饰器使用时:</p><pre class="line-numbers language-none"><code class="language-none">class a:def __init__(self):self._x = None@propertydef x(self):return self._x@x.fsetdef x(self, x):self._x = x@x.fdeldef x(self):self._x = None参数:fget – 获取属性值的函数fset – 设置属性值的函数fdel – 删除属性值函数doc – 属性描述信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>range(start,stop[,step]):range并不是一个函数, range时一个不可变序列类型,返回一个迭代器对象.</p><pre class="line-numbers language-none"><code class="language-none">In [149]: list(range(1, 10, 2))Out[149]: [1, 3, 5, 7, 9]In [150]: list(range(1, 10))Out[150]: [1, 2, 3, 4, 5, 6, 7, 8, 9]In [151]: list(range(10))Out[151]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [152]: type(range) # 非函数Out[152]: type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repr(object): 返回可打印的字符串,此函数尝试返回一个字符串，该字符串在传递时会产生具有相同值的对象eval()，否则表示形式是一个括在尖括号中的字符串，其中包含对象类型的名称以及其他信息通常包括对象的名称和地址。类可以通过定义__repr__()方法来控制此函数为其实例返回的内容.</p><pre class="line-numbers language-none"><code class="language-none">In [154]: repr(1)Out[154]: '1'In [155]: class a:...:     def __repr__(self): return "1"In [156]: repr(a())Out[156]: '1'In [157]: repr(a)Out[157]: "&lt;class '__main__.a'&gt;"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reversed(seq):接受一个可迭代类型, 返回该可迭代类型的反向迭代器.</p><pre class="line-numbers language-none"><code class="language-none">In [161]: list(reversed(range(10)))Out[161]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>round(num, [, ndigits]): 返回num四舍五入精确到ndigits精度数字, 如果没有传入ndigits则返回最接近num的整数, 如果num时一个自定义对象, 则调用__round__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [163]: round(1.2563, 2)Out[163]: 1.26In [164]: round(1.2563)Out[164]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>set([iterable]):返回一个新的set类型对象, 接受可选可迭代类型参数, 并将可迭代类型参数转换成set类型返回.</p><pre class="line-numbers language-none"><code class="language-none">In [166]: set()Out[166]: set()In [167]: set([1,2,3])Out[167]: {1, 2, 3}In [168]: set(range(10))Out[168]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>setattr(object, name, value): 接受三个必选参数, 将object.name属性赋值为value.</p><pre class="line-numbers language-none"><code class="language-none">In [172]: class a: passIn [173]: a1 = a()In [174]: setattr(a1, "b", 1)In [175]: a1.bOut[175]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slice(start,stop[,step]):返回表示由指定的索引集的切片对象, 该对象为只读数据属性.</p><pre class="line-numbers language-none"><code class="language-none">In [178]: slice(0, 1)Out[178]: slice(0, 1, None)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>sorted(iterable,*,key=None,reverse=False):将_iterable_对象排序后返回.</p><pre class="line-numbers language-none"><code class="language-none">key: 可选关键字参数,_key_指定一个参数的函数，该函数用于从_iterable中的_每个元素中提取比较键reverse: 可选关键字参数, 如果设置为True，则列表元素将按照每个比较相反的方式进行排序.In [181]: sorted(["12", "1", "34", "6", "90"], key=int)Out[181]: ['1', '6', '12', '34', '90']In [182]: sorted(["12", "1", "34", "6", "90"], key=int, reverse=True)Out[182]: ['90', '34', '12', '6', '1']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@staticmethod: 装饰器函数, 作用于类方法上, 将方法转换成静态方法.</p><pre class="line-numbers language-none"><code class="language-none">In [185]: class a:...:     @staticmethod...:     def b(x):...:         return xIn [186]: a.b(1)Out[186]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>str(object=b’’,encoding=’utf-8’,errors=’strict’):返回一个字符串类型的对象,如果object是一个自定义对象, 那么首先会调用对象的__str__方法, 如果没有实现__str__方法则调用__repr__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [194]: class a:...:     def __repr__(self): return "re"...:     def __str__(self): return "str"In [195]: str(a())Out[195]: 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sum(iterable[,start]):如果没有传入_start_参数, 则将_iterable_所有的元素叠加后返回, 如果传入了_start_参数,则从_start_参数开始将_iterable_的元素从左至右的叠加.</p><pre class="line-numbers language-none"><code class="language-none">In [201]: sum([1,2,3], 8)Out[201]: 14In [207]: sum(range(1, 101))Out[207]: 5050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>super([type[,object-or-type]]):该函数用于调用父类(超类)的一个方法.</p><pre class="line-numbers language-none"><code class="language-none">In [209]: class a:...:     def add(self, x):...:         return x + 1In [210]: class b(a):...:     def add(self, x):...:         return super().add(x)In [211]: b().add(1)Out[212]: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tuple([iterable]):返回一个元组对象, 接受一个可选的可迭代参数, 如果传入了该参数则将该参数转换成元组对象.</p><pre class="line-numbers language-none"><code class="language-none">In [214]: tuple([1,2,3,4])Out[214]: (1, 2, 3, 4)In [215]: tuple()Out[215]: ()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>type(name,bases,dict):只传入一个参数时将返回该参数的类型,使用三个参数，返回一个新类型对象,name则成为类对象的名称,base则表明了其父类, 可选的关键字参数则将成为类的属性.(type是类型实例关系的顶端, object是父子关系的顶端，所有的数据类型的父类都是它, Object是type的一个实例,Type是object的子类, 详细见type和object之间的关系)</p><pre class="line-numbers language-none"><code class="language-none">In [222]: d = type("objects", (), {"names": "this is name"})In [223]: dOut[223]: __main__.objectsIn [224]: d.namesOut[224]: 'this is name'In [217]: type(1)Out[217]: int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vars([object]):返回模块、类、实例、其他对象的__dict__属性.</p><pre class="line-numbers language-none"><code class="language-none">In [232]: class a:...:     x = 1In [233]: vars(a)Out[233]:mappingproxy({'__module__': '__main__','x': 1,'__dict__': &lt;attribute '__dict__' of 'a' objects&gt;,'__weakref__': &lt;attribute '__weakref__' of 'a' objects&gt;,'__doc__': None})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zip(*iterables):将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表,如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同.</p><pre class="line-numbers language-none"><code class="language-none">In [237]: zip([1,2,3,4], ["q", "w", "e", "r"])Out[237]: &lt;zip at 0x2aec3ad6d88&gt;In [238]: list(zip([1,2,3,4], ["q", "w", "e", "r"]))Out[238]: [(1, 'q'), (2, 'w'), (3, 'e'), (4, 'r')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>import(name,globals=None,locals=None,fromlist=(),level=0):import 语句将会调用该函数,该函数导入模块_name_, 使用给定的_globals和_locals来确定如何解释包上下文中的名称.</p><pre class="line-numbers language-none"><code class="language-none">In [240]: __import__("requests")Out[240]: &lt;module 'requests' from 'd:\\anaconda3\\envs\\python3\\lib\\site-packages\\requests\\__init__.py'&gt;In [241]: requests = __import__("requests")In [242]: requests.__version__Out[242]: '2.21.0'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aiohttp,asyncio,RunTimeError</title>
      <link href="/2017/07/13/aiohttp-asyncio-runtimeerror/"/>
      <url>/2017/07/13/aiohttp-asyncio-runtimeerror/</url>
      
        <content type="html"><![CDATA[<p>首先，你得到的AssertionError: There is no current event loop in thread ‘Thread-1’.是因为asyncio程序中的每个线程都有自己的事件循环，但它只会在主线程中为你自动创建一个事件循环。所以如果你asyncio.get_event_loop在主线程中调用一次，它将自动创建一个循环对象并将其设置为默认值，但是如果你在一个子线程中再次调用它，你会得到这个错误。相反，您需要在线程启动时显式创建/设置事件循环：</p><pre class="line-numbers language-none"><code class="language-none">loop = asyncio.new_event_loop()asyncio.set_event_loop(loop)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一旦你这样做，你应该能够使用get_event_loop()在特定的线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--dict的优点以及缺点</title>
      <link href="/2017/06/17/liu-chang-de-python-dict-de-you-dian-yi-ji-que-dian/"/>
      <url>/2017/06/17/liu-chang-de-python-dict-de-you-dian-yi-ji-que-dian/</url>
      
        <content type="html"><![CDATA[<p>1.健必须是可散列的。<br>用户自己实现的对象默认都是可散列的，因为id()不同。一个可散列对象应该有以下属性：<br>支持hash()函数，通过hash()方法得到的散列值是不变的。<br>可以通过eq()方法来检测相等性<br>如果a == b，那么hash(a) == hash(b)</p><p>2.字典内存开销大<br>因为字典是由散列表实现的，散列表中肯定对出现一些稀疏，这就导致了字典会占用一些空间。当然和字典的速度相比这点内存是可以忽略的。</p><p>3.字典的健顺序不是唯一的<br>由于散列表在插入或者读取时候可能会产生散列冲突，这就导致了字典中健的顺序不是唯一的，但是不管字典健的顺序怎么变，如果两个字典健值对都一样那么这两个字典都是相等的：</p><pre class="line-numbers language-none"><code class="language-none">a = {"1":1,"2":3,"3":4,"4":4}b = {"3":3,"4":4,"1":1,"2":2}a == bTrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--字典中的散列表</title>
      <link href="/2017/06/15/liu-chang-de-python-zi-dian-zhong-de-san-lie-biao/"/>
      <url>/2017/06/15/liu-chang-de-python-zi-dian-zhong-de-san-lie-biao/</url>
      
        <content type="html"><![CDATA[<p>字典中的散列表其实就是稀疏数组（总会有一些元素是空白的数组），散列表中的单元叫：表元，在构建字典时会有产生两个表元，一个用来标记健，一个用来标记值，因为两个表元的长度都是相等的，所以可以通过表元的偏移量来查找字典。<br>python中最具有效率的内置数据类型就是字典和集合，这两种都是通过散列表来实现的。为了测试python中字典，集合和其他的数据类型的速度我做了以下的实验：</p><pre class="line-numbers language-none"><code class="language-none">import timeMAX = 10000000list_a = [i for i in range(MAX)]set_a = set(list_a)dict_a = {}.fromkeys(list_a)test = [i for i in range(1000)]def testTime(x,name):start = time.clock()for i in test:if i in x:passprint name,':','%f' % (time.clock() - start)testTime(list_a, 'list')testTime(set_a, 'set')testTime(dict_a, 'dict')``````结果：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>list : 0.012472<br>set : 0.000079<br>dict : 0.000071</p><pre><code>从上面可以看出集合与字典相比其他类型要快得多，这是因为列表中没有散列表支持in运算符。散列的算法：比如python要获取dict[key]背后的值，python会先使用hash(key)来计算key的散列值，用然后去散列值的最低位的几位数字作为表元的偏移量，如果表元是空的，就会抛出一个KeyError异常，如果找到，就会获得一个:key:value值，python再最后会比较两个key的散列值是否一致。如果为真返回value，如果不相等这时候就称为散列冲突。这种情况的发生是因为散列表把随机的元素映射到几位数字上去。而散列表有依赖这个数字做检索。为了解决这个问题，散列表就会再从新取几位数字，去表元中寻找。如果表元为空这回抛出一个keyerror异常，如果没有找到就会重复上面的步骤直到找到。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--特殊方法</title>
      <link href="/2017/06/15/liu-chang-de-python-te-shu-fang-fa/"/>
      <url>/2017/06/15/liu-chang-de-python-te-shu-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>python中的特殊方法是主要是被python解释器调用，再大部分情况下不需要自己去实现特殊方法，比如len(x)，这里实际上是调用的len()方法，但是在实际中我们不会去使用x.len()这样的书写。如果x是一个自己实现的类并且再类里面实现了一个len()方法，那么python就会去调用这个类里面的方法。<br>大部分情况下调用特殊方法都是隐性调用。比如: for i in x: 这里实际是调用了x的iter()方法，所有的特殊方法都可以自定义。但是在编程时是不建议大量的实现特殊方法，除非元编程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python根据exif信息旋转图片</title>
      <link href="/2017/06/08/python-gen-ju-exif-xin-xi-xuan-zhuan-tu-pian/"/>
      <url>/2017/06/08/python-gen-ju-exif-xin-xi-xuan-zhuan-tu-pian/</url>
      
        <content type="html"><![CDATA[<p>这几天在写业务代码有个需求：压缩图片。本来是很简单需求，三下五除二就写好了，但是在自己用手机上传图片的时候发现压缩后的图片都歪了，查了一下，原因是图片中的exif信息中的Orientation记录中图片的旋转角度。需要根据这个来旋转图片。</p><p>首先读取图片的exif信息：</p><pre class="line-numbers language-none"><code class="language-none">from PIL import Imageimg = Image.open('1.jpg')# 先判断图片是否有exif信息if hasattr(img, '_getexif'):# 获取exif信息dict_exif = img._getexif()if dict_exif(274, 0) == 3:# 旋转new_img = img.rotate(-90)elif dict_exif(274, 0) == 6:# 旋转new_img = img.rotate(180)else:new_img = imgelse:new_img = imgnew_img.save('new_1.jpg', )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的高级用法 -- namedtuple</title>
      <link href="/2017/06/07/python-de-gao-ji-yong-fa-namedtuple/"/>
      <url>/2017/06/07/python-de-gao-ji-yong-fa-namedtuple/</url>
      
        <content type="html"><![CDATA[<p>namedtuple函数用来构建一个有名字的元组或者类，这种方法可以更有效的调试<br>代码：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; from collections import namedtuple# 创建一个类&gt;&gt;&gt; a = namedtuple('c', ('name', 'age'))&gt;&gt;&gt; x = a('perror', 21)&gt;&gt;&gt; print xc(name='perror', age=21)&gt;&gt;&gt; # 该返回值可以用访问对象的方法来访问&gt;&gt;&gt; print x.nameperror&gt;&gt;&gt; print x.age21&gt;&gt;&gt; # 也可以用标的方式去访问&gt;&gt;&gt; print x[0]perror<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命名元组除了继承普通元组的方法外还有额外的三个方法：_fields 类属性，make() 类方法，_asdict() 类实例方法</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; # 查看该命名元组中的所有字段&gt;&gt;&gt; x._fields('name', 'age')&gt;&gt;&gt; # _make 通过一个可迭代对象来生成一个类实例&gt;&gt;&gt;s = ('perror', '21')&gt;&gt;&gt; new_s = x._make(s)&gt;&gt;&gt; # 通过类实例方法更友好的打印出元组的字段&gt;&gt;&gt;new_s._asdict()OrderedDict([('name', 'perror'), ('age', 23)])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
