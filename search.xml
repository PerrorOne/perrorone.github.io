<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何在k8s中使用GCS备份ES数据</title>
      <link href="//post/ru-he-zai-k8s-zhong-shi-yong-gcs-bei-fen-es-shu-ju.html"/>
      <url>//post/ru-he-zai-k8s-zhong-shi-yong-gcs-bei-fen-es-shu-ju.html</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch 是一个超级炫酷的开源搜索引擎，可以在各种不同的环境中使用。为了妥善保管数据，就必须得备份 ES 集群数据。鉴于公司的 k8s 集群部署在 GCP 上，自然而然想到了使用 GCS 作为备份数据存储，为了做到这一步需要以下步骤：</p><ol><li>创建一个服务帐号供 repository-gcs 插件使用，一定要注意这个服务账号必须要有gcs的权限。</li><li>创建一个脚本，该脚本需要创建备份repository、检查备份任务等等。</li></ol><h3 id="配置-GCS-存储桶"><a href="#配置-GCS-存储桶" class="headerlink" title="配置 GCS 存储桶"></a>配置 GCS 存储桶</h3><p>首先，需要创建一个 GCS 存储桶并配置访问权限。还需要创建一个用于备份的服务账号，并赋予它存储桶的写入权限。最后，在 k8s 中配置该服务账号的密钥，以便可以使用它来访问 GCS。(由于公司集群就在GCP上部署，所以我没有这样做，而是使用了<a href="https://cloud.google.com/iam/docs/workload-identity-federation?hl=zh-cn">工作负载身份联合</a>)</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> gcs<span class="token punctuation">-</span>credentials<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">stringData</span><span class="token punctuation">:</span>  <span class="token key atrule">credentials.json</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    {      "type": "service_account",      "project_id": "my-project",      "private_key_id": "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",      "private_key": "-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0B...",      "client_email": "my-service-account@my-project.iam.gserviceaccount.com",      "client_id": "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",      "auth_uri": "https://accounts.google.com/o/oauth2/auth",      "token_uri": "https://accounts.google.com/o/oauth2/token",      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/my-service-account%40my-project.iam.gserviceaccount.com"    }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置-ES-集群"><a href="#配置-ES-集群" class="headerlink" title="配置 ES 集群"></a>配置 ES 集群</h2><p>然后需要在 ES 集群中配置 GCS 备份。可以使用<code>repository-gcs</code> 插件来实现。该插件可以将 ES 数据备份到 GCS 存储桶中，并从存储桶中恢复数据。需要在每个 ES 节点上安装该插件，并在集群配置文件中添加 GCS 存储桶的详细信息。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> elasticsearch.k8s.elastic.co/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Elasticsearch<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> elastic<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">nodeSets</span><span class="token punctuation">:</span><span class="token punctuation">...</span>      <span class="token key atrule">podTemplate</span><span class="token punctuation">:</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> es <span class="token comment"># 使用了[工作负载身份联合](https://cloud.google.com/iam/docs/workload-identity-federation?hl=zh-cn)</span><span class="token punctuation">...</span>          <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install<span class="token punctuation">-</span>plugins <span class="token comment"># 安装插件</span>              <span class="token key atrule">command</span><span class="token punctuation">:</span>                <span class="token punctuation">-</span> sh                <span class="token punctuation">-</span> <span class="token punctuation">-</span>c                <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">                  bin/elasticsearch-plugin install --batch repository-gcs</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建备份计划"><a href="#创建备份计划" class="headerlink" title="创建备份计划"></a>创建备份计划</h2><p>由于我们需要让es开启定期备份所以我们需要使用一个脚本，在ES启动后检查该任务是否存在，如果不存在则创建，为了能够将该脚本在ES中使用，我们需要为该脚本创建一个configmap。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$ES_URL</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token assign-left variable">ES_URL</span><span class="token operator">=</span><span class="token string">"http://localhost:9200"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$ES_USERNAME</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"ES_USERNAME is not set"</span>  <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$ES_PASSWORD</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"ES_PASSWORD is not set"</span>  <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$BUCKET</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token assign-left variable">BUCKET</span><span class="token operator">=</span><span class="token string">"es-backup"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$BASE_PATH</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token assign-left variable">BASE_PATH</span><span class="token operator">=</span><span class="token string">"backup"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$SNAPSHOT_NAME</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token assign-left variable">SNAPSHOT_NAME</span><span class="token operator">=</span><span class="token string">"test"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$SCHEDULE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token assign-left variable">SCHEDULE</span><span class="token operator">=</span><span class="token string">"0 0 14 * * ?"</span> <span class="token comment"># 每天14点执行</span><span class="token keyword">fi</span><span class="token assign-left variable">AUTH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$ES_USERNAME</span>:<span class="token variable">$ES_PASSWORD</span>"</span> <span class="token operator">|</span> base64<span class="token variable">)</span></span><span class="token keyword">while</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> /dev/null <span class="token parameter variable">-w</span> <span class="token string">"%{http_code}"</span> <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Basic <span class="token variable">$AUTH</span>"</span> $ES_URL<span class="token variable">)</span></span>"</span> <span class="token operator">!=</span> <span class="token string">"200"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Elasticsearch is not ready yet"</span>    <span class="token function">sleep</span> <span class="token number">1</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"Elasticsearch is up and running!"</span><span class="token comment"># 检查_snapshot/$SNAPSHOT_NAME是否存在，如果不存在则创建</span><span class="token assign-left variable">resp</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> /dev/null <span class="token parameter variable">-w</span> <span class="token string">"%{http_code}"</span> <span class="token parameter variable">-X</span> GET  <span class="token string">"<span class="token variable">$ES_URL</span>/_snapshot/<span class="token variable">$SNAPSHOT_NAME</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Accept: application/json"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Basic <span class="token variable">$AUTH</span>"</span><span class="token variable">)</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$resp</span> <span class="token operator">==</span> <span class="token string">"200"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$SNAPSHOT_NAME</span> snapshot already exists."</span><span class="token keyword">else</span>    <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> /dev/null <span class="token parameter variable">-w</span> <span class="token string">"%{http_code}"</span> <span class="token parameter variable">-X</span> PUT <span class="token string">"<span class="token variable">$ES_URL</span>/_snapshot/<span class="token variable">$SNAPSHOT_NAME</span>"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-H</span> <span class="token string">"Accept: application/json"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-H</span> <span class="token string">"content-type: application/json"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Basic <span class="token variable">$AUTH</span>"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-d</span> <span class="token string">"{            <span class="token entity" title="\&quot;">\"</span>type<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span>gcs<span class="token entity" title="\&quot;">\"</span>,            <span class="token entity" title="\&quot;">\"</span>settings<span class="token entity" title="\&quot;">\"</span>: {              <span class="token entity" title="\&quot;">\"</span>bucket<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span><span class="token variable">$BUCKET</span><span class="token entity" title="\&quot;">\"</span>,              <span class="token entity" title="\&quot;">\"</span>base_path<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span><span class="token variable">$BASE_PATH</span><span class="token entity" title="\&quot;">\"</span>            }          }"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-q</span> <span class="token string">"200"</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$SNAPSHOT_NAME</span> snapshot has been created."</span><span class="token keyword">fi</span><span class="token comment"># 检查snapshot policy是否存在，如果不存在则创建</span><span class="token assign-left variable">resp</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> /dev/null <span class="token parameter variable">-w</span> <span class="token string">"%{http_code}"</span> <span class="token parameter variable">-X</span> GET  <span class="token string">"<span class="token variable">$ES_URL</span>/_slm/policy/<span class="token variable">$SNAPSHOT_NAME</span>-snapshots"</span> <span class="token punctuation">\</span>           <span class="token parameter variable">-H</span> <span class="token string">"Accept: application/json"</span> <span class="token punctuation">\</span>           <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Basic <span class="token variable">$AUTH</span>"</span><span class="token variable">)</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$resp</span> <span class="token operator">==</span> <span class="token string">"200"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$SNAPSHOT_NAME</span>-snapshots snapshot policy already exists."</span><span class="token keyword">else</span>    <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> /dev/null <span class="token parameter variable">-w</span> <span class="token string">"%{http_code}"</span> <span class="token parameter variable">-X</span> PUT  <span class="token string">"<span class="token variable">$ES_URL</span>/_slm/policy/<span class="token variable">$SNAPSHOT_NAME</span>-snapshots"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-H</span> <span class="token string">"Accept: application/json"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-H</span> <span class="token string">"content-type: application/json"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Basic <span class="token variable">$AUTH</span>"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">-d</span> <span class="token string">"{            <span class="token entity" title="\&quot;">\"</span>schedule<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span><span class="token variable">$SCHEDULE</span><span class="token entity" title="\&quot;">\"</span>,            <span class="token entity" title="\&quot;">\"</span>name<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span>&lt;<span class="token variable">$SNAPSHOT_NAME</span>-snapshots-{now/d/H}&gt;<span class="token entity" title="\&quot;">\"</span>,            <span class="token entity" title="\&quot;">\"</span>repository<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span><span class="token variable">$SNAPSHOT_NAME</span><span class="token entity" title="\&quot;">\"</span>,            <span class="token entity" title="\&quot;">\"</span>config<span class="token entity" title="\&quot;">\"</span>: {                <span class="token entity" title="\&quot;">\"</span>expand_wildcards<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span>all<span class="token entity" title="\&quot;">\"</span>,                <span class="token entity" title="\&quot;">\"</span>ignore_unavailable<span class="token entity" title="\&quot;">\"</span>: true,                <span class="token entity" title="\&quot;">\"</span>include_global_state<span class="token entity" title="\&quot;">\"</span>: false            },            <span class="token entity" title="\&quot;">\"</span>retention<span class="token entity" title="\&quot;">\"</span>: {              <span class="token entity" title="\&quot;">\"</span>expire_after<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span>30d<span class="token entity" title="\&quot;">\"</span>,              <span class="token entity" title="\&quot;">\"</span>min_count<span class="token entity" title="\&quot;">\"</span>: 5,              <span class="token entity" title="\&quot;">\"</span>max_count<span class="token entity" title="\&quot;">\"</span>: 50            }          }"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-q</span> <span class="token string">"200"</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$SNAPSHOT_NAME</span>-snapshots snapshot policy has been created."</span><span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token string">"sleep forever"</span><span class="token function">sleep</span> infinity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终的ES配置文件为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: elasticsearch.k8s.elastic.co/v1kind: Elasticsearchmetadata:  name: elasticspec:  nodeSets:    - name: default      count: <span class="token number">1</span>      config:        action.destructive_requires_name: <span class="token boolean">true</span>        cluster.max_shards_per_node: <span class="token number">4000</span>      volumeClaimTemplates:        - metadata:            name: elasticsearch-data          spec:            accessModes: <span class="token punctuation">[</span><span class="token string">"ReadWriteOnce"</span><span class="token punctuation">]</span>            storageClassName: premium-rwo            resources:              requests:                storage: 200Gi      podTemplate:        spec:          serviceAccountName: es-backup          volumes:            - name: create-elasticsearch-snapshot-entrypoint <span class="token comment"># 引入脚本configmap</span>              configMap:                name: create-elasticsearch-snapshot-script                defaultMode: 0744          initContainers:            - name: install-plugins              command:                - <span class="token function">sh</span>                - <span class="token parameter variable">-c</span>                - <span class="token operator">|</span>                  bin/elasticsearch-plugin <span class="token function">install</span> <span class="token parameter variable">--batch</span> repository-gcs          containers:            - name: elasticsearch              resources:                requests:                  memory: 6Gi                  cpu: 2000m                limits:                  memory: 8Gi                  cpu: 4000m            - name: create-elasticsearch-snapshot <span class="token comment"># 创建任务脚本配置</span>              image: curlimages/curl:8.2.1              command:                - <span class="token function">sh</span>                - <span class="token parameter variable">-c</span>                - <span class="token function">sh</span> /usr/local/bin/create_elasticsearch_snapshot.sh              env:                - name: ES_URL                  value: <span class="token string">"http://localhost:9200"</span>                - name: ES_USERNAME                  value: <span class="token string">"elastic"</span>                - name: ES_PASSWORD                  valueFrom:                    secretKeyRef:                      name: elastic-subscan-es-elastic-user                      key: elastic                - name: BUCKET                  value: <span class="token string">"es-backup"</span>                - name: BASE_PATH                  value: <span class="token string">"staging"</span>                - name: SNAPSHOT_NAME                  value: <span class="token string">"test"</span>                - name: SCHEDULE                  value: <span class="token string">"0 0 14 * * ?"</span> <span class="token comment"># 每天14点执行</span>              volumeMounts:                - name: create-elasticsearch-snapshot-entrypoint                  mountPath: /usr/local/bin/create_elasticsearch_snapshot.sh                  subPath: entrypoint.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在确保 ES 数据备份安全的同时，我们还可以将备份数据用于测试和开发环境。此外，我们可以在 GCS 存储桶中设置生命周期规则以自动删除旧备份，从而节省存储空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js压缩导致的BUG</title>
      <link href="//post/js-ya-suo-dao-zhi-de-bug.html"/>
      <url>//post/js-ya-suo-dao-zhi-de-bug.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>基于gin-vue-admin项目开发了一个后台管理项目，在上线后一直挺好的，但是最近一段时间总是出现各种问题， 比如登录成功后白屏、切换路由之后白屏以及动态切换路由显示错误。<br>这些问题非常奇怪，在本地开发环境一切正常，只要上了服务器就有问题。</p><h2 id="Debug过程"><a href="#Debug过程" class="headerlink" title="Debug过程"></a>Debug过程</h2><ol><li>首先想到的是线上build的前端node版本与本地node版本不同，开发环境使用的是16.17.0，服务器中使用的是16.所以就先将服务器中的node版本降级到16.17.0，但是问题依旧。</li><li>在查看服务器版本的报错信息之后发现是某个js出现了错误：<code>o.exports=a(1.valueOf)o.exports=a(1.valueOf)</code> 这行代码导致的问题，于是对比服务器上文件以及本地文件发现了问题，本地文件是<code>o.exports=a(1 .valueOf)</code>，服务器文件是<code>o.exports=a(1.valueOf)</code>，缺少了一个空格，随即联想到是cloudflare的js压缩导致的问题。</li><li>尝试关闭cloudflare auto minify功能后再次尝试，问题解决。</li><li>但这也不是办法，再给cloudflare反馈的同时，需要继续查出为什么会这样， 于是在项目中搜索<code>1 .valueOf</code>类似的代码，发现了<code>1..valueOf</code>这样的代码，应该就是这个问题导致了</li><li>该代码在<a href="https://github.com/flipped-aurora/gin-vue-admin/blob/main/server/resource/page/js/chunk-vendors.2e7c88f1.js">chunk-vendors.2e7c88f1.js</a>中，但是由于作者没有写上任何关于该文件的来源（没有版本号、commit hash），但是可以了解到这是可以正常运行的。</li><li>那么为什么<code>1..valueOf</code>会被改成<code>1 .valueOf</code>这样了？只有一种可能那就是又被压缩了，于是发现了<a href="https://github.com/flipped-aurora/gin-vue-admin/blob/main/server/resource/page/js/chunk-vendors.2e7c88f1.js">chunk-vendors.2e7c88f1.js</a>根本没有直接输出，而最后<code>1 .valueOf</code>代码是由vite生成的于是上面的debug步骤作废。</li><li>于是发现了<a href="https://cn.vitejs.dev/config/build-options.html#build-minify">https://cn.vitejs.dev/config/build-options.html#build-minify</a> 文档中显示默认使用了esbuild来压缩文件，于是尝试着使用terser来压缩文件，问题解决。</li></ol><p>最后吐槽一下js的语法都是什么神操作，<code>1 .valueOf</code>这样的东西都能够正常运行，前端难做啊😯</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to install the Velero backup application on GKE</title>
      <link href="//post/shi-yong-velero-bei-fen-gke-ji-qun.html"/>
      <url>//post/shi-yong-velero-bei-fen-gke-ji-qun.html</url>
      
        <content type="html"><![CDATA[<h3 id="Versions"><a href="#Versions" class="headerlink" title="Versions"></a>Versions</h3><ul><li>velero: v1.9.0</li><li>gke: v1.25.6-gke.200</li><li>velero helm charts: 2.30.1</li><li>flux cd: 0.36.0</li></ul><h3 id="Import-helm-chart-repository"><a href="#Import-helm-chart-repository" class="headerlink" title="Import helm chart repository"></a>Import helm chart repository</h3><ul><li>Create vmware-tanzu-helmrepo.yaml, add the following content and submit it to the git repository:</li></ul><pre class="line-numbers language-none"><code class="language-none">apiVersion: source.toolkit.fluxcd.io/v1beta2kind: HelmRepositorymetadata:  name: vmware-tanzuspec:  interval: 30m  url: &lt;https://vmware-tanzu.github.io/helm-charts&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Check if the helmrepo is working fine: <code>kubectl get helmrepository -A | grep vmware-tanzu</code>. The output should be as follows:</li></ul><pre class="line-numbers language-none"><code class="language-none">flux-system   vmware-tanzu           &lt;https://vmware-tanzu.github.io/helm-charts&gt;            117d   True    stored artifact for revision 'eff1284a69fc7293ad2a4618c30d63ef6f486bd74ea3a8d3301866b899facdf6'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Install-velero"><a href="#Install-velero" class="headerlink" title="Install velero"></a>Install velero</h3><ul><li>Create velero-release.yaml, add the following content and submit it to the git repository:</li></ul><pre class="line-numbers language-none"><code class="language-none">apiVersion: helm.toolkit.fluxcd.io/v2beta1kind: HelmReleasemetadata:  name: velerospec:  chart:    spec:      chart: velero      sourceRef:        kind: HelmRepository        name: vmware-tanzu        namespace: flux-system      version: "2.30.1"  interval: 1h  maxHistory: 3  values:    backupsEnabled: false    snapshotsEnabled: true # Enable VolumeSnapshotLocation    deployRestic: true # If you need to use restic to back up PVC data, you need to enable this option    restic: # It is recommended to increase the default resource limits, otherwise backup may fail due to insufficient resources      resources:        requests:          cpu: 1000m          memory: 2Gi        limits:          cpu: 2000m          memory: 4Gi    configuration:      provider: gcp # Introduce GCP      features: "EnableUploadProgress" # Enable upload progress    initContainers: # Introduce GCP plugins      - name: velero-plugin-for-gcp        image: velero/velero-plugin-for-gcp:v1.4.1        imagePullPolicy: IfNotPresent        volumeMounts:          - mountPath: /target            name: plugins    credentials:      useSecret: false # We use workload identity    serviceAccount:      server:        create: true        name: velero        annotations: # Use GKE's workload identity and remember to give GCS permissions          iam.gke.io/gcp-service-account: &lt;service-account-name&gt;@&lt;project-name&gt;.iam.gserviceaccount.com    rbac:      create: true      clusterAdministrator: true    schedules: {}    resources:      requests:        cpu: 100m        memory: 500Mi      limits:        cpu: 1000m        memory: 1000Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Wait for fluxcd to automatically deploy velero. If the following pod appears, the installation is successful:</p><p><img src="https://s1.ax1x.com/2023/03/11/ppuHcX6.png" alt="https://s1.ax1x.com/2023/03/11/ppuHcX6.png"></p></li><li><p>Check if the CRD is created successfully: <code>kubectl get crd | grep velero</code>. The output should be as follows:</p><p><img src="https://s1.ax1x.com/2023/03/11/ppuHR0O.png" alt="https://s1.ax1x.com/2023/03/11/ppuHR0O.png"></p></li></ul><h3 id="Test-backup"><a href="#Test-backup" class="headerlink" title="Test backup"></a>Test backup</h3><ul><li>Create a test pod and PVC and deploy:</li></ul><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: test-backup-volume-claim  namespace: stagingspec:  storageClassName: test-backup-storage-class  accessModes:    - ReadWriteOnce  resources:    requests:      storage: 1Gi---apiVersion: v1kind: Podmetadata:  name: test-backup  namespace: staging  labels:    app: test-backupspec:  containers:    - name: test-backup      image: nginx      volumeMounts:        - mountPath: "/var/www/html"          name: mypd  volumes:    - name: mypd      persistentVolumeClaim:        claimName: test-backup-volume-claim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Write file data to <code>/var/www/html</code> in the pod.</li><li>Create a backup plan:</li></ul><pre class="line-numbers language-none"><code class="language-none">apiVersion: velero.io/v1kind: Schedulemetadata:  name: test-backup  namespace: velerospec:  schedule: "0 14 * * 1"  template:    includedNamespaces:      - staging    volumeSnapshotLocations: [default]    storageLocation: default    includedResources:      - "*"    labelSelector:      matchLabels:        app: test-backup    snapshotVolumes: true    defaultVolumesToRestic: true    ttl: 168h # 7 days<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Create a backup based on the schedule: <code>velero backup create --from-schedule test-backup</code>. The return value is as follows:</li></ul><pre class="line-numbers language-none"><code class="language-none">Creating backup from schedule, all other filters are ignored.Backup request "test-backup-20230314070438" submitted successfully.Run `velero backup describe test-backup-20230314070438` or `velero backup logs test-backup-20230314070438` for more details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Use <code>velero backup describe test-backup-20230314070438 --details</code> to check the task status.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to fix the &quot;no matches for kind &quot;PodSecurityPolicy&quot; in version &quot;policy/v1beta1&quot; error in Grafana</title>
      <link href="//post/grafana-no-matches-for-kind-podsecuritypolicy-error.html"/>
      <url>//post/grafana-no-matches-for-kind-podsecuritypolicy-error.html</url>
      
        <content type="html"><![CDATA[<p>After upgrading the cluster to Kubernetes 1.25, if Grafana was deployed previously with <code>rbac.spsEnabled=true</code> enabled, the error “grafana no matches for kind ‘PodSecurityPolicy’ in version ‘policy/v1beta1’” will occur. This is because the previously deployed Grafana created a PodSecurityPolicy version of policy/v1beta1, which is no longer supported in Kubernetes 1.25, resulting in an error.</p><p>To resolve this issue, follow these steps:</p><ol><li>Obtain Grafana’s Secrets</li></ol><pre class="line-numbers language-none"><code class="language-none">&gt; kubectl get secret -n prometheus | grep grafanagrafana                                                      Opaque               3      106dsh.helm.release.v1.grafana.v3                                       helm.sh/release.v1   1      105dsh.helm.release.v1.grafana.v4                                       helm.sh/release.v1   1      105dsh.helm.release.v1.grafana.v5                                       helm.sh/release.v1   1      97d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>Backup sh.helm.release.v1.grafana.v3 | sh.helm.release.v1.grafana.v4 | sh.helm.release.v1.grafana.v5</li></ol><pre class="line-numbers language-none"><code class="language-none">kubectl get secret sh.helm.release.v1.grafana.v3 -n prometheus -o yaml &gt; release.v3.yamlkubectl get secret sh.helm.release.v1.grafana.v4 -n prometheus -o yaml &gt; release.v4.yamlkubectl get secret sh.helm.release.v1.grafana.v5 -n prometheus -o yaml &gt; release.v5.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>Delete sh.helm.release.v1.grafana.v3 | sh.helm.release.v1.grafana.v4 | sh.helm.release.v1.grafana.v5</li></ol><pre class="line-numbers language-none"><code class="language-none">kubectl delete secret sh.helm.release.v1.grafana.v3 -n prometheuskubectl delete secret sh.helm.release.v1.grafana.v4 -n prometheuskubectl delete secret sh.helm.release.v1.grafana.v5 -n prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>Use fluxctl reconcile grafana helmrelease</li></ol><pre class="line-numbers language-none"><code class="language-none">flux reconcile helmrelease grafana -n prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Check Grafana helmrelease’s status. If it becomes READY and no errors occur, the problem has been successfully resolved.</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install fluxcd in k8s 1.25.5</title>
      <link href="//post/install-fluxcd-in-k8s-1-25-5.html"/>
      <url>//post/install-fluxcd-in-k8s-1-25-5.html</url>
      
        <content type="html"><![CDATA[<p>Here are the steps to use Flux CD for GitOps on Kubernetes:</p><ol><li>Install Flux CLI: Use the command <code>brew install fluxcd/tap/flux</code> to install.</li><li>Display Flux CLI version: Use the command <code>flux version</code> to display Flux CLI version information.</li><li>Create a Git repository on GitHub.</li><li>Set the GITHUB_TOKEN environment variable.</li><li>Use the command <code>flux bootstrap github</code> to install Flux CD into the Kubernetes cluster. In the command, specify the GitHub username and repository name, read/write key, branch, and the components to use (including image-reflector-controller and image-automation-controller).</li><li>Wait for the Flux CD Pod to start and complete initialization.</li></ol><p>Note that only with the <code>--components-extra=image-reflector-controller,image-automation-controller</code> parameter can you create pods related to images.</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql error: rec.cc:391 thread </title>
      <link href="//post/mysql-error-rec-cc-391-thread.html"/>
      <url>//post/mysql-error-rec-cc-391-thread.html</url>
      
        <content type="html"><![CDATA[<p>此错误仅在 MySQL 8.0.30 版本中存在。请参见 <a href="https://bugs.mysql.com/bug.php?id=107941">https://bugs.mysql.com/bug.php?id=107941</a> bug 报告。升级 MySQL 版本到 8.0.31 可以解决此错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何清理 Kubernetes namespace 中的 finalizers 并成功删除 argocd namespace</title>
      <link href="//post/ru-he-qing-li-kubernetes-namespace-zhong-de-finalizers-bing-cheng-gong-shan-chu-argocd-namespace.html"/>
      <url>//post/ru-he-qing-li-kubernetes-namespace-zhong-de-finalizers-bing-cheng-gong-shan-chu-argocd-namespace.html</url>
      
        <content type="html"><![CDATA[<p>在删除 Kubernetes 集群中的资源时，我遵循以下步骤：</p><ol><li>删除所有 <code>deploy</code>。</li><li>删除所有 <code>configmap</code>。</li><li>删除所有 <code>namespace</code>。</li></ol><p>&nbsp;&nbsp;然而，我发现在删除 <code>namespace</code> 时出现了问题。尝试了官方提供的命令<br><code>kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</code><br>但是 <code>namespace</code> 删除仍然被卡住了。我注意到该 <code>namespace</code> 下存在多个 <code>argoproj.io/v1alpha1/applications</code> 资源，并且所有资源都包含一个 <code>finalizers</code> 字段。通过搜索引擎，我了解到只有删除所有资源 YAML 文件中的 <code>finalizers</code> 字段才能解决 <code>namespace</code> 删除被卡住的问题。因此，我直接删除了 <code>finalizers</code> 字段并更新了所有资源，直到所有资源都被修改好为止。最终，<code>namespace</code> 能够被成功删除。<br>&nbsp;&nbsp;在 Kubernetes 中，删除某些资源时，这些资源可能具有关联的其他资源，这些关联资源需要被清理，以便能够顺利删除要删除的资源。当某个 <code>namespace</code> 中存在关联资源时，删除该 <code>namespace</code> 可能会失败。在这种情况下，Kubernetes 会在 <code>namespace</code> 对应的 <code>finalizers</code> 列表中添加一些条目，以确保所有关联资源被清理，然后再删除 <code>namespace</code>。在删除 <code>namespace</code> 时，Kubernetes 会检查 <code>finalizers</code> 列表中的所有条目，确保这些条目对应的所有资源已被清理，然后才会继续删除 <code>namespace</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s PVC Auto Scaling Practice</title>
      <link href="//post/k8s-pvc-zi-dong-kuo-rong-shi-jian.html"/>
      <url>//post/k8s-pvc-zi-dong-kuo-rong-shi-jian.html</url>
      
        <content type="html"><![CDATA[<h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><p>This practice depends on:</p><ol><li>k8s version &gt;= 1.24</li><li><a href="https://github.com/topolvm/pvc-autoresizer">pvc-autoresizer</a> version &gt;= 0.5.0</li></ol><h2 id="Install-pvc-autoresizer"><a href="#Install-pvc-autoresizer" class="headerlink" title="Install pvc-autoresizer"></a>Install pvc-autoresizer</h2><ol><li>Clone the <a href="https://github.com/topolvm/pvc-autoresizer">pvc-autoresizer</a> repository and checkout version 0.5.0, then build and push the Docker image:</li></ol><pre class="line-numbers language-none"><code class="language-none">git clone &lt;https://github.com/topolvm/pvc-autoresizer&gt; &amp;&amp; git checkout v0.5.0 &amp;&amp; cd pvc-autoresizer &amp;&amp; docker build -t pvc-autoresizer:0.5.0 . &amp;&amp; docker push pvc-autoresizer:0.5.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>Add the pvc-autoresizer Helm repo:</li></ol><pre class="line-numbers language-none"><code class="language-none">helm repo add pvc-autoresizer &lt;https://topolvm.github.io/pvc-autoresizer/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>Prepare the <code>values.yaml</code> file with the following content:</li></ol><pre class="line-numbers language-none"><code class="language-none"># config from &lt;https://github.com/topolvm/pvc-autoresizer/blob/main/charts/pvc-autoresizer/values.yaml&gt;image:  # image.repository -- pvc-autoresizer image repository to use.  repository: perrorone/pvc-autoresizer  # image.tag -- pvc-autoresizer image tag to use.  # @default -- `{{ .Chart.AppVersion }}`  tag:  v0.5.0controller:  # controller.replicas -- Specify the number of replicas of the controller Pod.  replicas: 1  args:    # controller.args.prometheusURL -- Specify Prometheus URL to query volume stats.    # Used as "--prometheus-url" option    prometheusURL: &lt;you_prometheus_url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Install pvc-autoresizer:</li></ol><pre class="line-numbers language-none"><code class="language-none">helm install --create-namespace --namespace pvc-autoresizer pvc-autoresizer pvc-autoresizer/pvc-autoresizer --values ./values.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>Check if the installation was successful:</li></ol><pre class="line-numbers language-none"><code class="language-none">kubectl get pod -n pvc-autoresizer | grep pvc-autoresizer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Create-StatefulSet-and-Storage-Class"><a href="#Create-StatefulSet-and-Storage-Class" class="headerlink" title="Create StatefulSet and Storage Class"></a>Create StatefulSet and Storage Class</h2><ol><li>Write the <code>stateful-set.yaml</code> file with the following content:</li></ol><pre class="line-numbers language-none"><code class="language-none">apiVersion: storage.k8s.io/v1kind: StorageClassmetadata:  name: test-pvc-autoresizer  namespace: staging  annotations:    resize.topolvm.io/enabled: "true" # Must be present to auto-scaleparameters:  type: pd-ssdprovisioner: pd.csi.storage.gke.ioreclaimPolicy: RetainvolumeBindingMode: WaitForFirstConsumerallowVolumeExpansion: true---apiVersion: apps/v1kind: StatefulSetmetadata:  name: test-pvc-autoresizer  namespace: stagingspec:  selector:    matchLabels:      app: test-pvc-autoresizer  serviceName: "test-pvc-autoresizer"  replicas: 1  template:    metadata:      labels:        app: test-pvc-autoresizer    spec:      terminationGracePeriodSeconds: 10      containers:        - name: test-pvc-autoresizer          image: perrorone/go-file:v1.0.0          ports:            - containerPort: 80              name: http          livenessProbe:            httpGet:              path: /health              port: http          readinessProbe:            httpGet:              path: /health              port: http          volumeMounts:            - name: test-pvc-data              mountPath: /data          resources:            requests:              cpu: 200m              memory: 300Mi            limits:              cpu: 500m              memory: 500Mi  volumeClaimTemplates:    - metadata:        name: test-pvc-data        annotations:  # Must be present to auto-scale            resize.topolvm.io/storage_limit: 8Gi # Maximum scaling size            resize.topolvm.io/threshold: 20%      spec:        accessModes: [ "ReadWriteOnce" ]        storageClassName: "test-pvc-autoresizer"        resources:          requests:            storage: 1Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Deploy StatefulSet and Storage Class:</li></ol><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f ./stateful-set.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ol><li>Enter the pod and check the mounted directory size. You can see that the <code>/data</code> directory is only using 1% of its space:</li></ol><pre class="line-numbers language-none"><code class="language-none">df -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>Test automatic scaling by writing a file:</li></ol><pre class="line-numbers language-none"><code class="language-none">dd if=/dev/zero of=1G.file bs=50M count=20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>Check the pvc-autoresizer pod log:</li></ol><p><a href="https://imgse.com/i/ppCS1Zn"><img src="https://s1.ax1x.com/2023/02/27/ppCS1Zn.jpg" alt="ppCS1Zn.jpg"></a></p><ol start="4"><li>Check the mounted directory size again. You can see that the mounted directory has already reached 100% usage: <code>/dev/sdf 975.9M 959.9M 0 100% /data</code></li><li>After waiting for some time, check the mounted directory size again. You can see that it has successfully scaled: <code>/dev/sdf 1.9G 960.4M 1007.4M 49% /data</code>😋😋😋😋😋😋<br><a href="https://imgse.com/i/ppCSQqs"><img src="https://s1.ax1x.com/2023/02/27/ppCSQqs.jpg" alt="ppCSQqs.jpg"></a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的一些小知识</title>
      <link href="//post/redis-de-yi-xie-xiao-zhi-shi.html"/>
      <url>//post/redis-de-yi-xie-xiao-zhi-shi.html</url>
      
        <content type="html"><![CDATA[<h3 id="Redis数据类型的使用场景"><a href="#Redis数据类型的使用场景" class="headerlink" title="Redis数据类型的使用场景"></a>Redis数据类型的使用场景</h3><ul><li>String：其value可以储存string以及数字类型，一般用于复杂的技术功能上。</li><li>Hash：其value存放的是结构化的对象，可以方便地操作某个字段，我使用它实现过用户行为数据缓存以及session功能。</li><li>List：类似Python中的list数据类型，我一般使用它做消息队列或者分页功能。</li><li>Set：该数据结构储存的是一系列无序、不重复的数据，还提供差集、交集等功能。我使用它为爬虫去重以及用户阅读过的文章功能。</li><li>Sorted Set：有序集合储存一系列有序、不重复的数据，大多数场景都使用它做一个榜单的功能。</li></ul><h3 id="Redis的一些缺点"><a href="#Redis的一些缺点" class="headerlink" title="Redis的一些缺点"></a>Redis的一些缺点</h3><ul><li>Redis将所有数据放在内存中以便加快访问的速度，但这也造成了Redis容量受到物理内存大小的限制，所以Redis对于一些海量数据场景有些乏力。</li><li>Redis的在线扩容比较麻烦。如果Redis集群数量到达上限时，此时在线扩容是一个十分复杂的问题，大大提高了运维的成本。</li></ul><h3 id="Redis的过期策略以及内存淘汰机制"><a href="#Redis的过期策略以及内存淘汰机制" class="headerlink" title="Redis的过期策略以及内存淘汰机制"></a>Redis的过期策略以及内存淘汰机制</h3><ul><li>Redis采用了定时删除+惰性删除的方式来删除过期的数据。这里的定时删除，Redis并非将所有设置过期时间的key都遍历一遍，如果这样做将会消耗大量的CPU资源。Redis采用了随机抽样，如果被抽到的key过期了就删除。但如果仅仅是这样，那么有可能一些数据永远不会被抽到。这时Redis引入了惰性删除，在访问KEY的时候检查一下是否过期，过期就删除。</li><li>如果Redis仅仅采用上面两种方式来删除数据，那么在极端情况下仍然会有数据不会被删除。Redis还有内存淘汰策略，我最常使用的是allkeys-lru。当Redis内存到达上限时，它从所有key中寻找最近最少使用的KEY删除。</li></ul><h3 id="大量数据插入Redis应该怎么做？"><a href="#大量数据插入Redis应该怎么做？" class="headerlink" title="大量数据插入Redis应该怎么做？"></a>大量数据插入Redis应该怎么做？</h3><p>使用正常模式来插入显然不是一个明智的选择，而使用管道的话某些客户端会被阻塞，导致不能在这期间执行其他的命令。比较好的方案是根据Redis协议生成一个文件，然后使用pipe mode去执行这个文件。参考<a href="https://redis.io/docs/reference/patterns/bulk-loading/">Redis Mass Insertion</a>。</p><h3 id="Redis分区？"><a href="#Redis分区？" class="headerlink" title="Redis分区？"></a>Redis分区？</h3><ul><li>Redis的分区是指将数据分割成多个子集，分别保存到不同的Redis实例中，每一个Redis实例都只保存了KEY的一个子集。</li><li>Redis的分区在涉及多个key操作的时候，多数是不支持的，更别说多key事务操作。对于备份的情况也比较复杂。</li><li>Redis分区有两种类型：<ol><li>按照范围分区，映射一定范围的对象到特定的Redis实例，但这种并不长使用。</li><li>使用hash分区，其工作原理使用了hash表的原理，类似Python dict。</li></ol></li></ul><h3 id="Redis如何做集群？"><a href="#Redis如何做集群？" class="headerlink" title="Redis如何做集群？"></a>Redis如何做集群？</h3><p>推荐使用官方的<a href="https://redis.io/docs/management/scaling/">Redis Cluster</a>，其实现原理是：Redis集群内部有2<strong>14个哈希槽。当需要插入key时，首先对key使用<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81/10168758?fr=aladdin&amp;fromtitle=CRC%E6%A0%A1%E9%AA%8C&amp;fromid=3439037">crc16算法</a>计算出一个数字，在用此数字对2</strong>14取余，该取余结果就是数据存放的哈希槽位置。而Redis集群的节点管理这使用类似哨兵的机制来实现，集群类节点通过相互ping来判断节点是否能够连接。如果过半数节点都连接不上一个节点，则Redis集群就会认定此节点宕机了。该方案确并不能保证数据的强一致性，所以在使用时一定不要将Redis作为一个高可靠性的存储服务使用！</p><h3 id="Redis如何做持久化？"><a href="#Redis如何做持久化？" class="headerlink" title="Redis如何做持久化？"></a>Redis如何做持久化？</h3><p>Redis支持两种持久化方案：</p><ol><li>快照：通过对配置文件的设置，可以使Redis在N秒类M个key被修改时就将内存的数据以快照的方式写入到后缀为’.rdb’文件中。</li><li>AOF: 每一次收到一次写的命令就将此命令追加到后缀为’.aof’文件中，当Redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cast Type Conversion Library - Recommended Go Library</title>
      <link href="//post/cast-lei-xing-zhuan-huan-ku-go-ku-tui-jian.html"/>
      <url>//post/cast-lei-xing-zhuan-huan-ku-go-ku-tui-jian.html</url>
      
        <content type="html"><![CDATA[<p>In Go language, type conversion is a frequently used operation, but converting values between different types requires importing different libraries, which can be relatively cumbersome. However, the <code>cast</code> library solves this problem and provides many type conversion functions, usually only requiring the import of this one library.</p><p>The <code>cast</code> library not only provides conversions between common types, such as int to string, but also provides more complex type conversions, such as converting a time string to the <code>time.Time</code> type. In addition, it provides two conversion functions, one only returns the zero value of that type without returning an error, and the other returns an error, so developers can choose to use it according to their actual needs.</p><p>Here are some commonly used APIs:</p><ul><li><code>cast.StringToDate</code>: Converts common time strings to the <code>time.Time</code> type.</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.StringToDate("2006-01-02 15:04:05"))// output: 2006-01-02 15:04:05 +0000 UTC &lt;nil&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>cast.ToBoolSlice</code>: Converts an array of any type to the <code>[]bool</code> type.</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToBoolSlice([]interface{}{1,2,0,true, false}))// output: [true true false true false]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>cast.ToBool</code>: Converts any type to the <code>bool</code> type.</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToBool(1)) // output:truefmt.Println(cast.ToBool(0)) // output: falsefmt.Println(cast.ToBool("")) // output: falsefmt.Println(cast.ToBool("0")) // output: falsefmt.Println(cast.ToBool("1")) // output: truefmt.Println(cast.ToBool("true")) // output: truefmt.Println(cast.ToBool("false")) // output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cast.ToString</code>: Converts any type to a string type.</li></ul><pre class="line-numbers language-none"><code class="language-none">cast.ToString("mayonegg")         // "mayonegg"cast.ToString(8)                  // "8"cast.ToString(8.31)               // "8.31"cast.ToString([]byte("one time")) // "one time"cast.ToString(nil)        // "nil"var foo interface{} = "one more time"cast.ToString(foo)                // "one more time"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cast.ToStringMap</code>: Converts a map of any type to <code>map[string]interface{}</code>.</li></ul><pre class="line-numbers language-none"><code class="language-none">fmt.Println(cast.ToStringMap(map[interface{}]interface{}{    1:2,    "2":3,    true:1,})) // output: map[1:2 2:3 true:1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>More APIs can be found in its documentation: <a href="https://github.com/spf13/cast">https://github.com/spf13/cast</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding Redis SDS</title>
      <link href="//post/sds-xiang-jie.html"/>
      <url>//post/sds-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<p>What is SDS?</p><p>SDS is an abstract type built by Redis, mainly used to store Redis’ default string representation, the AOF buffer in the AOF module, and the client state input buffer.</p><p>Advantages of SDS</p><p>Why doesn’t Redis use C strings? First, we need to understand the shortcomings of C strings:</p><ol><li>C strings do not record their own length information. Obtaining the length of a string requires traversing the entire string, with a time complexity of O(n).</li><li>C strings do not record their own length, and a slight mistake can cause a buffer overflow.</li><li>For cache-type databases like Redis, the value of the cache often changes frequently. However, each growth or reduction of a C string requires a memory reallocation operation.</li><li>The content cached in the Redis database is not specific, and it may be binary data such as images or audio files. However, the characters in C strings must comply with a certain encoding, and the strings cannot contain spaces. These restrictions also mean that Redis cannot use C strings as its own string implementation.</li></ol><p>SDS eliminates all these shortcomings one by one:</p><ol><li>SDS records its own length information, making the time complexity of obtaining the string length O(1).</li><li>SDS uses pre-allocated space and lazy space release algorithms to solve the problem of frequent memory allocation operations.</li><li>Since SDS saves its own length, SDS will not determine the end of the string like C does according to ‘\0’.</li></ol><p>Implementation of SDS</p><p>Redis uses the sdshdr structure to represent SDS values:</p><pre class="line-numbers language-none"><code class="language-none">struct sdshdr{   int len; // Records the number of bytes used in the buf array   int free; // Records the number of unused bytes in buf   char buf[]; // Save the array of strings}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SDS follows the convention of C strings ending with a null character so that functions in C strings can be reused. This null character at the end of the string does not increase the value of the len field. For example, if you need to use SDS to save the string “golang,” the SDS corresponding to the structure is:</p><p><img src="https://s1.ax1x.com/2022/03/25/qNgzqI.png" alt="https://s1.ax1x.com/2022/03/25/qNgzqI.png"></p><p>Since SDS records its own length, getting the length of the string in Redis only needs to return the len field, and its time complexity is O(1). The space allocation strategy of SDS completely eliminates the possibility of buffer overflow, which frequently occurs in C strings. When Redis needs to modify an SDS string, it first checks whether the space of the SDS satisfies the space required for the modification. If it does not meet the requirements, the space of the SDS will be expanded to meet the capacity required for the modification. The SDS space expansion algorithm is as follows:</p><ol><li>If the length of the SDS after modification is less than 1MB, the program will allocate unused space of the same size as the len field value. For the example above, the total capacity of the SDS is 6 (len) + 6 (free) + 1 (‘\0’) = 13 bytes.</li><li>If the length of the SDS after modification is greater than 1MB, the SDS will allocate 1MB of unused space. If the capacity of an SDS after the len value is modified is 2MB, Redis will allocate 1MB of unused space for the SDS. At this time, the total capacity of the SDS is 2MB (len) + 1MB (len) + 1byte (‘\0’) = 3073 byte capacity.</li></ol><p>This expansion algorithm reduces the frequency of requesting memory from the system. The SDS space release is not real-time but lazy: Redis believes that if the capacity of an SDS reaches N, it is likely to reach N after it is reduced. And lazy release also reduces the possibility of the next memory allocation. If there is a “golang” string stored in Redis now, and we need to modify “golang” to “go,” then the SDS structure of Redis will be like this:</p><p><img src="https://s1.ax1x.com/2022/03/25/qN2RTP.png" alt="https://s1.ax1x.com/2022/03/25/qN2RTP.png"></p><p><img src="https://s1.ax1x.com/2022/03/25/qN24fS.png" alt="https://s1.ax1x.com/2022/03/25/qN24fS.png"></p><p>SDS provides an API to clean up memory. We can call this API when needed to release memory.</p><p>Summary</p><ol><li>Redis only uses C strings as literals, and SDS is used to represent most strings.</li><li>The length of the string can be obtained with constant time complexity.</li><li>Eliminates buffer overflow.</li><li>Reduces the number of times memory needs to be reallocated for strings. And for binary data security, it is compatible with some C string functions.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explanation of Go channels</title>
      <link href="//post/go-de-channel-xiang-jie.html"/>
      <url>//post/go-de-channel-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<p>This article is based on the analysis of the source code of version golang 1.12.1, where the chan source code is located in the file go/src/runtime/chan.go.</p><h2 id="What-is-a-Channel"><a href="#What-is-a-Channel" class="headerlink" title="What is a Channel?"></a>What is a Channel?</h2><p>In the source code, a channel is actually a structure, with the following structure:</p><pre class="line-numbers language-none"><code class="language-none">type hchan struct {    qcount uint // the number of data in the queue    dataqsiz uint // the size of the circular queue    buf unsafe.Pointer // the element array that stores the data    elemsize uint16    closed uint32    elemtype *_type // the type of the element    sendx uint // the number of sends    recvx uint // the number of receives    recvq waitq // the structure to put the receiver when blocking    sendq waitq // the structure to put the sender when blocking    // Used to ensure concurrent safety of data    lock mutex}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sendx</code> and <code>recvx</code> need to be incremented each time data is read or written. The roles of <code>recvq</code> and <code>sendq</code> are to store the channel structures of the receiver or sender when the buffer is full.</p><h2 id="Creating-a-Channel"><a href="#Creating-a-Channel" class="headerlink" title="Creating a Channel"></a>Creating a Channel</h2><p>To create a channel, we use the <code>make</code> function, which actually calls the <code>makechan</code> function to create the channel. The function signature is as follows:</p><pre class="line-numbers language-none"><code class="language-none">func makechan(t *chantype, size int) *hchan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>T</code> is the type of data to be sent or received by the channel, and <code>size</code> is the second parameter of the <code>make</code> function, which specifies the buffer size of the channel. By default, it is 0, indicating an unbuffered channel. The function returns a pointer to the <code>hchan</code> structure. When creating a channel, the size of <code>t</code> is first checked. If it exceeds 65536 bytes, an error will be triggered. If the size of the data type passed through the channel meets the requirements, a memory space of a certain capacity will be created according to the characteristics of the <code>t</code> type, and this memory space will be copied to <code>buf</code>. It is worth mentioning that there is a variable called <code>debugChan</code> in the <code>chan</code> package, which is set to <code>false</code> by default. When it is set to <code>true</code>, some debug information will be printed when operating on the channel. This will help us quickly discover bugs caused by the channel.</p><h2 id="Sending-Data-to-a-Channel"><a href="#Sending-Data-to-a-Channel" class="headerlink" title="Sending Data to a Channel"></a>Sending Data to a Channel</h2><p>Sending data to a channel is implemented by the <code>chansend</code> function at <a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#71">chan.go:142</a>. The function first checks whether the current channel is nil and whether it is a buffered channel. If it is, it returns directly. If it is an unbuffered channel, it calls the <code>gopark</code> function at <code>proc.gp:284</code> to set the current goroutine to a waiting state. It then checks whether the channel is ready to receive data. If it is, it calls the <code>send</code> function at <code>chan.go:264</code> to send the data. The main function of <code>send</code> is to <code>copy</code> the data to be sent to <code>buf</code>. If the current channel is unbuffered, it locks the current goroutine by calling <code>lock</code>. After the current data is received, it calls <code>goready</code> to notify the runtime that the current goroutine is ready to run again. If the channel is buffered, it returns directly.</p><h2 id="Receiving-Data-from-a-Channel"><a href="#Receiving-Data-from-a-Channel" class="headerlink" title="Receiving Data from a Channel"></a>Receiving Data from a Channel</h2><p>Receiving data is actually the same as sending data, except that when the channel is buffered and no data has been sent to the channel, it directly stores the address of the variable that receives the chan data into the <code>sendq</code> structure. When there is data to be sent, if it finds data in <code>recvq</code>, it directly stores the data into the address in this structure instead of using <code>buf</code> to <code>copy</code> the data.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The channel uses the <code>copy buf</code> method to communicate and ultimately implements sharing memory through communication. When a goroutine is blocked, the system thread puts it into the <code>hchan.sendq</code> or <code>hchan.recvq</code> list. The <code>sudog</code> type structure in this list is the current goroutine, and this <code>sudog</code> structure contains a variable that holds a pointer to the channel. Previously, I only used chan without knowing its principle. After reading the source code, I understood the parts that I did not understand before. When writing this article, I followed the source code, so there may be some contradictions in the order.</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python IO Multiplexing Practice</title>
      <link href="//post/io-duo-lu-fu-yong-shi-jian.html"/>
      <url>//post/io-duo-lu-fu-yong-shi-jian.html</url>
      
        <content type="html"><![CDATA[<p>In the past few days, I have been studying the Tornado source code and found that although Tornado claims to use an asynchronous model, it actually implements an event loop using IO multiplexing. To deepen my understanding of IO multiplexing, I decided to implement a simple HTTP client myself to compare the performance difference between synchronous and IO multiplexing clients.</p><p>Without further ado, let’s first take a look at the most intuitive difference between synchronous and IO multiplexing clients. First, let’s use Tornado to implement a simple server:</p><pre class="line-numbers language-none"><code class="language-none"># -*- coding:utf-8 -*-from tornado.web import RequestHandler, Applicationfrom tornado.ioloop import IOLoopimport tornado.genclass TestHandle(RequestHandler):    async def get(self, *args, **kwargs):        await tornado.gen.sleep(1)        self.write("OK")if __name__ == '__main__':    app = Application([('/', TestHandle)])    app.listen(8080)    IOLoop.current().start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>We pause the server for 1 second when processing requests so that it is more convenient to observe the difference between the two client implementations. Next, let’s implement a synchronous client:</p><pre class="line-numbers language-none"><code class="language-none"># -*- coding:utf-8 -*-import socketimport timeREQUEST_STR = '{method} {path} HTTP/1.0\r\n\r\n'def block_client(hostname, port, method, path):    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.connect((hostname, port))    sock.send(REQUEST_STR.format(method=method, path=path).encode())    response_body = []    while True:        response_stream = sock.recv(1024)        if not response_stream:            return b"".join(response_body).decode()        response_body.append(response_stream)if __name__ == '__main__':    count = 3    start_time = time.time()    for _ in range(3):        block_client("127.0.0.1", port=8080, method="GET", path="/")    print("{} requests {} times, running time: {:.1f} seconds".format(block_client.__name__, count, time.time() - start_time))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Start the server and test how long it takes for the synchronous client to request the server:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; C:\Users\Administrator&gt;python client.pyblock_client requests 3 times, running time: 3.0 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>As expected, it takes a total of 3 seconds to make three requests because the server paused for 1 second. Next, let’s implement an IO multiplexing client and see how it performs:</p><pre class="line-numbers language-none"><code class="language-none">from selectors import DefaultSelector, EVENT_WRITE, EVENT_READimport socketimport timeREQUEST_STR = '{method} {path} HTTP/1.0\r\n\r\n'JOBS_COUNT = 0select = DefaultSelector()class NoBlockClient:    def __init__(self):        self.result = []    def request(self, method, hostname, port, path):        global JOBS_COUNT        JOBS_COUNT += 1        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        sock.setblocking(False)        try:            sock.connect((hostname, port))        except BlockingIOError:            pass        select.register(sock.fileno(), EVENT_WRITE, partial(self._send, sock, method, path))    def _send(self, sock, method, path):        select.unregister(sock.fileno())        sock.send(REQUEST_STR.format(method=method, path=path).encode())        select.register(sock.fileno(), EVENT_READ, partial(self._recv, sock))    def _recv(self, sock):        global JOBS_COUNT        response_stream = sock.recv(1024)        if not response_stream:            select.unregister(sock.fileno())            sock.close()            JOBS_COUNT -= 1        else:            self.result.append(response_stream)    def run(self):        while JOBS_COUNT:            events = select.select()            for key, mask in events:                callback = key.data                callback()        return self.resultstart_time = time.time()count = 3no_block_client = NoBlockClient()for _ in range(count):    no_block_client.request("GET", "127.0.0.1", 8080, "/")result = no_block_client.run()print("{} requests {} times, running time: {:.1f} seconds".format(NoBlockClient.__name__, count, time.time() - start_time))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Run the client:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; C:\Users\Administrator&gt;python no_block_client.pyNoBlockClient requests 3 times, running time: 1.0 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The difference in time is very obvious. Although the code looks particularly complicated, to put it bluntly, each function corresponds to an event registered in select. select monitors these events and runs the corresponding function if an event is triggered.</p><p>Let’s analyze the IO multiplexing client code:</p><ol><li><code>select = DefaultSelector()</code> This line of code returns the best implementation of IO multiplexing on the current platform, which are select, poll, epoll, dev/poll, and kqueue. Since I am testing on Windows, DefaultSelector() returns the select model.</li><li>The purpose of the <code>NoBlockClient.request</code> function is to create a non-blocking socket connection to the target server and register the current socket in select. When its status is writable, the NoBlockClient._send function is called, which is equivalent to a callback function.</li><li><code>NoBlockClient._send</code> is responsible for sending the message to the connected server, and finally, it registers the event to select like NoBlockClient.request does.</li><li><code>NoBlockClient._recv</code> is called when the registered event is readable. It reads the returned data from the server, and the complete request is finished.</li><li>The <code>NoBlockClient.run</code> function is mainly used to let select start looping to monitor the status of these registered events and run callback functions.</li></ol><p>The selectors module is a encapsulation of the select module, so we don’t have to worry about what model is needed on the current platform. It directly returns the best model for the current platform and integrates the APIs of various models to make it easier for users to write cross-platform code. The most commonly used models include select, poll, and epoll. Next, we will explain the differences, advantages, and disadvantages of these models, as well as their implementation methods.</p><ol><li>select: select puts the registered events into a list and copies them to the kernel space for monitoring. If one of these events changes, select will copy the list containing the events back to the user space, resulting in a huge waste of resources. If select needs to monitor more and more events, its performance will decrease linearly. Moreover, when select copies the time to the user space, it does not tell the user which event was triggered, but requires the user to traverse them by themselves. Since the more events select monitors, the worse the performance, the system kernel usually limits the number of events that the select model can monitor. In the Python source code (<a href="https://github.com/python/cpython/blob/master/Modules/selectmodule.c">github: selectmodule.c</a>), the number of events that select can monitor in Windows is limited to 512 using macro definitions. Of course, the biggest advantage of select is that it is supported by almost all platforms.</li><li>poll: The implementation method of poll is almost the same as that of select, so I won’t go into details. See <a href="https://blog.csdn.net/luojian5900339/article/details/54581852">Poll event mechanism</a> for details.</li><li>epoll: Compared with select and poll, epoll has undergone a qualitative change. Epoll inserts the registered events into a red-black tree, and each node in the red-black tree is a registered event. Because the time complexity of querying, inserting, and deleting a red-black tree is O(logn), epoll can manage events more conveniently, and it only returns the triggered events when an event is triggered, rather than all events, which greatly increases efficiency. For a more detailed introduction to the epoll model, see <a href="https://blog.csdn.net/apacat/article/details/51375950">Understanding and in-depth analysis of EPOLL</a>.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python dict</title>
      <link href="//post/dict.html"/>
      <url>//post/dict.html</url>
      
        <content type="html"><![CDATA[<p>Python’s <code>dict</code> is a mapping type that uses a hash table to store data, making the query speed time complexity O(1), which is a typical data structure that trades space for time.</p><p>When we create a <code>key-value</code> pair, we first apply the hash function to the <code>key</code> to obtain an integer array, take the remainder of this integer with the length of the array that stores the <code>value</code>, and obtain the index where the <code>value</code> is stored. When initializing <code>dict</code>, Python first allocates an array of about 8KB to store <code>value</code> (see the definition of the minimum capacity of the dictionary at line 111 of <code>dictobject.c</code>). If the position of the array is not enough to store it, the system will be asked to allocate an array twice the current capacity to store <code>value</code>.</p><p>For hash conflicts, Python chose to use open addressing to solve the problem: when a hash conflict occurs, the next candidate position is calculated through the probing function. If the next candidate position still has a conflict, continue to search down through the probing function until an empty slot is found to store the element to be inserted.</p><p><code>dict</code> initialization is completed in the function <a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c#L691">dictobject.PyDict_New:691</a>:</p><pre class="line-numbers language-none"><code class="language-none">PyObject * PyDict_New(void){    dictkeys_incref(Py_EMPTY_KEYS);    return new_dict(Py_EMPTY_KEYS, empty_values);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Since Python 3.6, the order of the keys in <code>dict</code> has been maintained in the order of insertion <a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c#L13">dictobject.c:13</a>:</p><pre class="line-numbers language-none"><code class="language-none">As of Python 3.6, this is compact and ordered. Basic idea is described here:* &lt;https://mail.python.org/pipermail/python-dev/2012-December/123028.html&gt;* &lt;https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>The implementation of <code>dict</code> and the method of solving hash conflicts are core issues of Python. Understanding these contents is of great help for Python’s performance optimization and underlying implementation.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python deep copy and shallow copy</title>
      <link href="//post/python-shen-kao-bei-qian-kao-bei.html"/>
      <url>//post/python-shen-kao-bei-qian-kao-bei.html</url>
      
        <content type="html"><![CDATA[<p>When it comes to object copying in Python, we need to understand the difference between is and ==:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; b = [1,2,3,4]&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bFalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>From the example above, we can see that the values in a and b are equal, but the result of is is different. This is because Python compares whether the values of a and b are equal, while is compares whether the object identities are equal. Therefore, in Python, we usually use == to compare the values of objects and use is to determine whether the values bound to objects are None. It should be noted that some beginners often make the mistake of using None to compare whether a string, list, or dictionary is empty, which is incorrect because these variables are not equal to None in terms of object identity or value.</p><p>In Python, we usually use shallow copy to copy objects. The copy module provides us with the copy (shallow copy) and deepcopy (deep copy) functions.</p><p>Shallow copy refers to copying a reference to the copied object, and the copied object points to the value of the object being copied. In other words, a reference is added to the original value.</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)4297636352&gt;&gt;&gt; id(b)4297636352<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Deep copy refers to copying the value of the copied object and creating a new object whose value and object identity are equal to the copied object.</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; b[1,2,3]&gt;&gt;&gt; a[1,2,3]&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; id(a)4297636352&gt;&gt;&gt; id(b)4297636352&gt;&gt;&gt; a.append(0)&gt;&gt;&gt; a[1,2,3,0]&gt;&gt;&gt; b[1,2,3]&gt;&gt;&gt; b.append(9)&gt;&gt;&gt; b[1, 2, 3, 9]&gt;&gt;&gt; a[1, 2, 3, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Based on this phenomenon, we should pay special attention to the use of mutable parameters as default parameters in functions. If we are not careful, we may encounter the following situation:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def a(x = []):...     x.append(0)...     print(x)&gt;&gt;&gt; a()[0]&gt;&gt;&gt; a()[0, 0]&gt;&gt;&gt; a()[0, 0, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>To avoid this situation, we should avoid using mutable objects as default function parameters:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def a(x = None):...     if x is None:...         x = []...     else:...         x.append(0)...     print(x)...&gt;&gt;&gt; a()[]&gt;&gt;&gt; a()[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>At the same time, when creating a class and passing parameters during initialization, shallow copy is also used to pass parameters, which can lead to the following situation:</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; class A:...     def __init__(self, name):...         self.name = name...     def printf(self):...         print(self.name)...&gt;&gt;&gt; x = [1,2,3,4]&gt;&gt;&gt; a = A(x)&gt;&gt;&gt; a.printf()[1, 2, 3, 4]&gt;&gt;&gt; x.append(5)&gt;&gt;&gt; a.printf()[1, 2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>When the passed-in parameter changes, the value of the variable in the class will also change, which is difficult to detect. The biggest difference between deep copy and shallow copy is that deep copy will copy the parent object and its sub-objects, while shallow copy only copies the parent object.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端传给前端int 类型数据自增或自减</title>
      <link href="//post/hou-duan-chuan-gei-qian-duan-int-lei-xing-shu-ju-zi-zeng-huo-zi-jian.html"/>
      <url>//post/hou-duan-chuan-gei-qian-duan-int-lei-xing-shu-ju-zi-zeng-huo-zi-jian.html</url>
      
        <content type="html"><![CDATA[<p>由于我使用的是Python 3，Python 中的 int 类型与其他语言中的 int 类型不同，Python 将 long 类型也加入到了 int 中。因此，在其他语言中能够正确显示的 int 类型，在 Python 中不一定能够正确显示。当 Python 传递的 int 超过了浏览器所能解析的最大值时，就会出现这种情况。建议将较大的 int 类型转换成字符串后再传给前端。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python内置函数</title>
      <link href="//post/python-nei-zhi-han-shu.html"/>
      <url>//post/python-nei-zhi-han-shu.html</url>
      
        <content type="html"><![CDATA[<p>abs(x): 接受一个整数或浮点数作为参数，返回该参数的绝对值，如果该参数是一个复数，则返回复数的模。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(4 - 8j)8.94427190999916<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>all(iter): 接受一个可迭代类型，如果该参数内所有元素为真返回True，否则返回False。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; all([1,2,3,4,5])True&gt;&gt;&gt; all([1,2,3,4,0])False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>any(iter):接受一个可迭代类型为参数,如果该参数内任何元素为真,则返回True,否则返回False.</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; any([0, 0,1])True&gt;&gt;&gt; any([0, 0,0])False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>asicc(object):接受一个对象, 将调用该对象的__repr__方法, 返回的字符串会将\x,\u,\U进行转移输出.</p><pre class="line-numbers language-none"><code class="language-none">In [4]: class a:...:     def __repr__(self):...:         return "repr"In [5]: ascii(a())Out[5]: 'repr'In [9]: ascii("\n\rfdsafdsa")Out[9]: "'\\n\\rfdsafdsa'"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bin(x):接受一个整数作为参数, 并将该参数转换成以”0b”前缀的二进制字符串,如果x不是一个整数,那么将会调用对象的__index__方法的整数并转换成二进制.</p><pre class="line-numbers language-none"><code class="language-none">In [15]: class a:...:     def __index__(self):...:         return 1In [14]: bin(1)Out[14]: '0b1'In [16]: bin(a())Out[16]: '0b1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bool([x]):如果不传参数,则默认返回Fase,如果X是一个不是整数或浮点数则首先调用对象的__bool__方法, 如果对象的__bool__方法未定义,其次调用__len__方法,如果返回0则bool()返回False,否则返回True,如果对象__len__、__bool__方法都未定义则默认返回True</p><pre class="line-numbers language-none"><code class="language-none">In [39]: bool(1)Out[39]: TrueIn [40]: bool(0.0)Out[40]: FalseIn [41]: bool(0 - 0j)Out[41]: FalseIn [43]: class a:...:     def __bool__(self): return True...:     def __len__(self): return 0In [45]: bool(a())Out[45]: TrueIn [44]: bool(a)Out[44]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytearray([source[, encoding[, errors]]]):接受一个大于等于0小于256的整数或者一个可迭代类型、如果参数一个字符串,那么必须指定encoding. 返回一个新的字节数组.如果传入一个对象首先调用该对象__index__, 如果未定义__index__则调用对象__iter__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [64]: class a:...:     def __iter__(self):...:         for i in range(0, 256):...:             yield i...:     def __index__(self): return 1...:In [65]: bytearray(a())Out[65]: bytearray(b'\x00')In [48]: bytearray()Out[48]: bytearray(b'')In [49]: bytearray([1,2,3,4,5,6,7])Out[49]: bytearray(b'\x01\x02\x03\x04\x05\x06\x07')In [77]: bytearray(1)Out[77]: bytearray(b'\x00')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytes([source[, encoding[, errors]]]): 如同bytearray使用方法, 不过该函数返回的一个不可变类型.</p><pre class="line-numbers language-none"><code class="language-none">In [72]: class a:...:     def __iter__(self):...:         for i in range(0, 256):...:             yield i...:     def __index__(self): return 1...:In [73]: bytes(a())Out[73]: b'\x00'In [79]: bytes(1)Out[79]: b'\x00'In [80]: bytes()Out[80]: b''In [81]: bytes([1,2,3,4,5,6,7])Out[81]: b'\x01\x02\x03\x04\x05\x06\x07'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>callable(object):接受一个对象作为参数, 如果该参数是可以调用的则返回True, 否则返回False</p><pre class="line-numbers language-none"><code class="language-none">In [83]: class a:passIn [85]: callable(a)Out[85]: TrueIn [86]: callable(a())Out[86]: FalseIn [88]: class a:...:     def __call__(self):...:         return 1In [89]: callable(a())Out[89]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>chr(i): 接受一个整数, 返回该整数对应的Unicode代码点的字符串,该整数必须大于等于0,小于等于1114112.</p><pre class="line-numbers language-none"><code class="language-none">In [105]: chr(0)Out[105]: '\x00'In [99]: chr(1114111)Out[99]: '\U0010ffff'In [100]: chr(1114112) # 超出范围---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-100-4857faf08086&gt; in &lt;module&gt;----&gt; 1 chr(1114112)ValueError: chr() arg not in range(0x110000)==<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@classmethod:装饰器, 作用于类方法上, 被装饰的方法将转换成类方法,类方法的一个参数将是类本身.</p><pre class="line-numbers language-none"><code class="language-none">In [110]: class a:...:     def a1(self):...:         print(self)...:     @classmethod...:     def a2(self): # 按照约定应该将self修改成cls来从字面量上区分类方法和实例方法....:         print(self)...:In [111]: a().a1() # 实例方法&lt;__main__.a object at 0x00000245CBE815C0&gt;In [112]: a.a2() # 类方法&lt;class '__main__.a'&gt;In [113]: a().a2() # 实例可以调用类方法&lt;class '__main__.a'&gt;In [115]: a.a1() # 类在未实例化之前不能调用实例化方法, 当然有捷径可以走,这里只是做了一个区分, 不展示捷径---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-115-2656506098d9&gt; in &lt;module&gt;----&gt; 1 a.a1()TypeError: a1() missing 1 required positional argument: 'self'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):将一个字符串编译成字节代码:</p><pre class="line-numbers language-none"><code class="language-none">source: 字符串或者AST对象,filename: 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值, 如’’.mode: 指定编译代码的种类。可以指定为 exec, eval, singleflags: 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。flags和dont_inherit是用来控制编译源码时的标志In [121]: d = compile("print(1)", "", "exec")In [122]: dOut[122]: &lt;code object &lt;module&gt; at 0x00000245CBF448A0, file "", line 1&gt;In [123]: exec(d)1complex([real[, imag]]): 创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In [125]: complex(1, 2)<br>Out[125]: (1+2j)<br>In [127]: complex(“1”)<br>Out[127]: (1+0j)<br>In [128]: complex(“1+2j”) # 此处不能有空格, 否则会报错<br>Out[128]: (1+2j)<br>delattr(object, name): 接受一个对象以及一个字符串,删除该对象的name属性,也可以使用del object.name来实现.</p><pre class="line-numbers language-none"><code class="language-none">In [144]: class a:...:     x = 1...:     y = 2...:In [145]: delattr(a, "x")In [147]: a.x---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-147-e27186f28a17&gt; in &lt;module&gt;----&gt; 1 a.xAttributeError: type object 'a' has no attribute 'x'In [148]: a.yOut[148]: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dict([object]):用于创建一个字典.如果不传参数,则返回一个空的字典.</p><pre class="line-numbers language-none"><code class="language-none">In [150]: dict()Out[150]: {}In [151]: dict(a=1, b=2)Out[151]: {'a': 1, 'b': 2}In [152]: dict({"a":1})Out[152]: {'a': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dir([object]):不传参数时, 返回当前范围内变量、方法和定义的类型列表,传入参数时返回该参数的所有的属性、方法, 如果该参数定义了__dir__方法, 则使用__dir__返回值, 否则该函数将尽可能的最大限度的收集该对象的方法以及属性.</p><pre class="line-numbers language-none"><code class="language-none">In [157]: dir("")Out[157]:['__add__','__class__','__contains__',...]In [155]: class a:...:     def __dir__(self):...:         return ["a", "b"]...:In [156]: dir(a())Out[156]: ['a', 'b']In [158]: class a:...:     x = 1...:     y = 2...:In [159]: dir(a)[...,'x','y']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>divmod(x, y): 接受两个非复数的数字作为参数, 返回X,Y的商和余.</p><pre class="line-numbers language-none"><code class="language-none">In [160]: divmod(1, 2)Out[160]: (0, 1)In [161]: divmod(1.5, 2)Out[161]: (0.0, 1.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>enumerate(iterable, start=0):接受一个可迭代类型以及一个可选int类型的参数, 返回一个枚举对象.如果指定了start则该可迭代对象的下边从start开始.</p><pre class="line-numbers language-none"><code class="language-none">In [163]: enumerate([1,2,3,4])Out[163]: &lt;enumerate at 0x245cbf50438&gt;In [164]: list(enumerate([1,2,3,4]))Out[164]: [(0, 1), (1, 2), (2, 3), (3, 4)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>eval(expression, globals=None, locals=None):接受一个字符串类型的表达式, 并执行该表达式,返回其值.</p><pre class="line-numbers language-none"><code class="language-none">expression: 字符串类型的表达式.globals: 字典类型, 变量作用域，全局命名空间.locals: 任何的映射对象, 变量作用域，局部命名空间.In [166]: eval("1 + 2")Out[166]: 3exec(object[, globals[, locals]]):该函数提供动态执行python代码的功能,object可以是字符串也可以是一个代码对象. globals必须是一个字典,locals则可以是任何的映射对象,In [168]: x = 1In [169]: exec("x + 2")In [172]: xOut[172]: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>filter(function,iterable):接受一个函数对象以及一个可迭代对象作为参数, 将可迭代对象中的每一个元素传入第一个参数中,如果该函数返回True则保留当前元素,否则删除当前元素.filter函数返回一个可迭代对象.</p><pre class="line-numbers language-none"><code class="language-none">In [3]: list(filter(lambda x: False, [1,2,3,4]))Out[3]: []In [4]: list(filter(lambda x: True, [1,2,3,4]))Out[4]: [1, 2, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>float([x]): 接受一个可选整型、浮点型、对象或者字符串类型参数, 返回该参数的浮点类型数据,如果X是一个自定义对象那么将调用对象的__float__方法(仅提供用方法, 完整方法见:float).</p><pre class="line-numbers language-none"><code class="language-none">In [6]: float("+1")Out[6]: 1.0In [7]: float("-1")Out[7]: -1.0In [8]: float("Inf")Out[8]: infIn [11]: float(1)Out[11]: 1.0In [12]: float(1.2)Out[12]: 1.2# 自定义对象In [14]: class a:...:     def __float__(self): return 1.0...:In [15]: float(a())Out[15]: 1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>format(value[,format_spec]):格式化字符串函数, 接受不限个参数，位置可以不按顺序, 其数字格式化符号见菜鸟教程, 对于自定义对象, 则调用对象的__format__方法, 如果对象没有定义__format__则使用对象__str__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [20]: "{}|{}".format(1, "dsa")Out[20]: '1|dsa'In [21]: "{1}|{0}".format(1, "dsa")Out[21]: 'dsa|1'In [22]: "{0}|{1}".format(1, "dsa")Out[22]: '1|dsa'In [23]: "{:.2f}".format(1.235646)Out[23]: '1.24'In [33]: class a:...:     def __format__(self, *args):...:         return "format"...:In [34]: "{}".format(a())Out[34]: 'format'In [36]: class a:...:     def __str__(self):...:         return "str"...:In [37]: "{}".format(a())Out[37]: 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>frozenset([iterable]): 接受一个可选的可迭代类型的参数, 返回一个frozenset对象, 该对象与set对象基本相似, 但是该对象是不可变的.</p><pre class="line-numbers language-none"><code class="language-none">In [39]: frozenset()Out[39]: frozenset()In [40]: frozenset([1,2,1,1])Out[40]: frozenset({1, 2})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getattr(object,name[,default]): 接受两个必选参数和一个可选参数, 该函数返回了object.name的值, 如果不存在name属性,并且没有传入default参数时则触发异常, 如果传入了default参数则没有找到name属性时返回default.</p><pre class="line-numbers language-none"><code class="language-none">In [45]: class a:...:     def b(self):...:         return "2"In [47]: getattr(a(), "b")()Out[47]: '2'getattr(a(), "b1", lambda : print("b1"))()b1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>globals(): 返回当前所有全局变量的字典.</p><pre class="line-numbers language-none"><code class="language-none">In [49]: globals()Out[49]:{'__name__': '__main__','__doc__': 'Automatically created module for IPython interactive environment','__package__': None,...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hasattr(object, name): 接受两个必选参数, 检测object中是否有那么属性.如果有name属性返回True,否则返回False.</p><pre class="line-numbers language-none"><code class="language-none">In [50]: class a:...:     b = 1...:In [51]: hasattr(a, "b")Out[51]: TrueIn [52]: hasattr(a, "b1")Out[52]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hash(object): 接受一个必选参数, 返回该对象的整型哈希值, 如果时自定义对象则调用对象的__hash__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [56]: hash("fdsaf")Out[56]: 2111967917974353823In [58]: class a:...:     def __hash__(self):...:         return 9527...:In [59]: hash(a())Out[59]: 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>help([object]): 接受一个可选的参数, 该参数可以是任意的类型, 返回该对象的帮助文档, 如果是自定义对象, 则返回该函数或者类的注释.如果没有传入参数则拉起交互式的帮助系统</p><pre class="line-numbers language-none"><code class="language-none">In [62]: help(1)Help on int object:class int(object)|  int(x=0) -&gt; integer...In [65]: class a:...:     """这是help信息"""...:     def b(self):...:         """这也是help信息"""...:         passIn [66]: help(a())Help on a in module __main__ object:class a(builtins.object)|  这是help信息||  Methods defined here:||  b(self)|      这也是help信息||  ----------------------------------------------------------------------|  Data descriptors defined here:||  __dict__|      dictionary for instance variables (if defined)||  __weakref__|      list of weak references to the object (if defined)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hex(x):接受一个整型作为必选参数, 返回该参数的16进制字符串, 该字符串以0x开头,如果x是一个自定义对象那么该对象必须实现__index__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [72]: hex(185)Out[72]: '0xb9'In [74]: class a:...:     def __index__(self): return 1In [75]: hex(a())Out[75]: '0x1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>id(object): 返回该对象在内存中的地址以整型返回.</p><pre class="line-numbers language-none"><code class="language-none">In [77]: id(1)Out[77]: 1786755536In [81]: class a:...:     def __init__(self, x):...:         self.x = x...:In [82]: id(a(1)) == id(2)Out[82]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>input([prompt]): 从标准输入中读取输入一回车键结束, 如果传入prompt, 则将prompt打印到标准输出中.</p><pre class="line-numbers language-none"><code class="language-none">In [84]: input("这是提示:")这是提示:ddOut[84]: 'dd'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>int(x, base=10):将一个字符串或数字转换为整型,如果没有传入参数则返回0,如果传入传入了base则表示X是base进制的数字.如果X是一个自定义对象, 则调用__init__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [86]: int()Out[86]: 0In [87]: int(1.0)Out[87]: 1In [90]: int("0x9b", 16)Out[90]: 155In [91]: class a:...:     def __int__(self):...:         return 1In [92]: int(a())Out[92]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>isinstance(object, classinfo):如果object是classinfo的实例或者子类的实例, 返回True, 否则返回False.如果classinfo是一个元组, 那么object只要是元组中任意一个元素的子类的实例或者实例化都返回True.</p><pre class="line-numbers language-none"><code class="language-none">In [94]: class a: passIn [95]: class b(a): passIn [99]: isinstance(b(), a)Out[99]: TrueIn [101]: isinstance(1, int)Out[101]: TrueIn [103]: isinstance(1, str)Out[103]: False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>issubclass(class, classinfo):如果class是classinfo的子类返回true, 使用方法与isinstance相同.</p><pre class="line-numbers language-none"><code class="language-none">In [94]: class a: passIn [95]: class b(a): passIn [105]: issubclass(b, a)Out[105]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>iter(object[,sentinel]):返回一个迭代器对象, 如果没有传入第二个参数, 那么object必须是实现了迭代协议或者序列协议否则将触发TypeError, 如果传入了sentinel参数那么object必须是可调用对象, 此时每迭代一次都调用object,如果object返回的值等于sentinel时,触发StopIteration异常.</p><pre class="line-numbers language-none"><code class="language-none">In [108]: iter([1,2,3])Out[108]: &lt;list_iterator at 0x210bde35f98&gt;In [110]: class a:...:     def __iter__(self):...:         for i in range(10):...:             yield i...:In [111]: list(iter(a()))Out[111]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [12]: def a():...:     global num...:     num += 1...:     if num &gt;= 10:...:         return -1...:     return numIn [13]: for i in iter(a, -1):...:     print(i)123456789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>len(s): 接受一个序列或者集合类型对象, 返回其长度, 如果时自定义对象, 将会调用对象的__len__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [18]: len([1,2,3])Out[18]: 3In [19]: len({1:2, 3:4})Out[19]: 2In [20]: class a:...:     def __len__(self): return 1In [21]: len(a())Out[21]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>locals():返回当前本地和只有变量的值.</p><pre class="line-numbers language-none"><code class="language-none">In [24]: def a():...:     x = 1...:     print(locals())In [25]: a(){'x': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>map(function,iterable…):返回一个迭代器, 该函数将function应用与每一个iterable元素上并返回直到可迭代对象耗尽.</p><pre class="line-numbers language-none"><code class="language-none">In [27]: map(lambda x: x ** 2, [1,2,3])Out[27]: &lt;map at 0x2aec3ae4a20&gt;In [28]: list(map(lambda x: x ** 2, [1,2,3]))Out[28]: [1, 4, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>max(arg1,arg2,*args[,key]):接受多个位置参数或者一个可迭代对象, 返回其中最大的值.</p><pre class="line-numbers language-none"><code class="language-none">In [39]: max(1,2)Out[39]: 2In [40]: max([2,3,4,5])Out[40]: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>memoryview(obj): 返回obj的内存查看对象(对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问).</p><pre class="line-numbers language-none"><code class="language-none">In [43]: a = b"dsadsad"In [44]: d = memoryview(a)In [47]: d[0]Out[47]: 10# 未复制数据In [52]: id(d.obj)Out[52]: 2949631565952In [53]: id(a)Out[53]: 2949631565952<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>min(arg1，arg2，* args[，key]): 接受多个位置参数或者一个可迭代对象, 返回其中最小的值.</p><pre class="line-numbers language-none"><code class="language-none">In [55]: min(1,2)Out[55]: 1In [56]: min([1,2,3,5])Out[56]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>next(iterator[,default]): 通过调用iterator的__next__方法并返回其值.</p><pre class="line-numbers language-none"><code class="language-none">In [58]: class a:...:     def __next__(self):...:         for i in range(10):...:             yield iIn [60]: list(next(a()))Out[60]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>object(): 返回一个新的无任何特征的对象, object时所有class的基类.</p><pre class="line-numbers language-none"><code class="language-none">In [105]: object()Out[105]: &lt;object at 0x2aec3a34880&gt;In [106]: class a:passIn [107]: issubclass(a, object)Out[107]: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>oct(x):接受一个整型作为参数返回以”0o”为前缀的八进制字符串,如果x是自定义对象, 则调用该对象的__index__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [109]: oct(1)Out[109]: '0o1'In [111]: class a:...:     def __index__(self): return 1In [112]: oct(a())Out[112]: '0o1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>open(file,mode=’r’,buffering=-1,encoding=None,errors=None,newline=None,<br>closefd=True,opener=None):打开file文件并返回一个文件对象, 具体参数值见open.</p><pre class="line-numbers language-none"><code class="language-none">file: 文件所在的路径以及文件名mode: 打开文件的模式, 默认"r”buffering: 用于设置缓冲策略, 0为关闭缓冲, 1为选择行缓冲, &gt; 1以指示固定大小的块缓存区.默认-1,二进制文件以固定大小的块缓冲 4.encoding:用于解码或编码文件的编码的名称, 默认编码取决于所在的操作系统 5.errors:指定如何处理编码和解码错误, 仅能在文本模式下使用 6.newline: 控制通用换行模式的工作方式（仅适用于文本模式）。它可以是None，''，'\n’，'\r’，和’\r\n’In [114]: open("test.test", "w").write("fdsa")Out[114]: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ord(c): 接受一个字符串类型参数, 返回该Unicode代码点的整数.</p><pre class="line-numbers language-none"><code class="language-none">In [116]: ord("a")Out[116]: 97In [117]: ord("你")Out[117]: 20320<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pow(x,y[,z]):当未传入Z参数时,返回x的y次方,如果传入了Z则对结果取余.</p><pre class="line-numbers language-none"><code class="language-none">In [122]: pow(2,3)Out[122]: 8In [124]: pow(2,3, 2)Out[124]: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>print(*objects,sep=’ ‘,end=’\n’,file=sys.stdout,flush=False):将objects对象打印到标准输出中,每一个objects使用sep分割, 以end结束,对于自定义对象, 首先调用对象__str__方法, 如果没有定义__str__方法则调用__repr__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [136]: class a:...:     def __str__(self): return "str"...:     def __repr__(self): return "repr"In [137]: print(a())str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>property(fget=None，fset=None，fdel=None，doc=None): 可作为装饰器使用也可作为函数使用.用于显示类属性的读取、设置以及删除. 作为函数使用时:</p><pre class="line-numbers language-none"><code class="language-none">In [140]: class a:...:     def __init__(self):...:         self._x = None...:...:     def getx(self):...:         return self._x...:...:     def setx(self, x):...:         self._x = x...:     def delx(self):...:         self._x = None...:     x = property(getx, setx, delx, "test")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为装饰器使用时:</p><pre class="line-numbers language-none"><code class="language-none">class a:def __init__(self):self._x = None@propertydef x(self):return self._x@x.fsetdef x(self, x):self._x = x@x.fdeldef x(self):self._x = None参数:fget – 获取属性值的函数fset – 设置属性值的函数fdel – 删除属性值函数doc – 属性描述信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>range(start,stop[,step]):range并不是一个函数, range时一个不可变序列类型,返回一个迭代器对象.</p><pre class="line-numbers language-none"><code class="language-none">In [149]: list(range(1, 10, 2))Out[149]: [1, 3, 5, 7, 9]In [150]: list(range(1, 10))Out[150]: [1, 2, 3, 4, 5, 6, 7, 8, 9]In [151]: list(range(10))Out[151]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [152]: type(range) # 非函数Out[152]: type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repr(object): 返回可打印的字符串,此函数尝试返回一个字符串，该字符串在传递时会产生具有相同值的对象eval()，否则表示形式是一个括在尖括号中的字符串，其中包含对象类型的名称以及其他信息通常包括对象的名称和地址。类可以通过定义__repr__()方法来控制此函数为其实例返回的内容.</p><pre class="line-numbers language-none"><code class="language-none">In [154]: repr(1)Out[154]: '1'In [155]: class a:...:     def __repr__(self): return "1"In [156]: repr(a())Out[156]: '1'In [157]: repr(a)Out[157]: "&lt;class '__main__.a'&gt;"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reversed(seq):接受一个可迭代类型, 返回该可迭代类型的反向迭代器.</p><pre class="line-numbers language-none"><code class="language-none">In [161]: list(reversed(range(10)))Out[161]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>round(num, [, ndigits]): 返回num四舍五入精确到ndigits精度数字, 如果没有传入ndigits则返回最接近num的整数, 如果num时一个自定义对象, 则调用__round__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [163]: round(1.2563, 2)Out[163]: 1.26In [164]: round(1.2563)Out[164]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>set([iterable]):返回一个新的set类型对象, 接受可选可迭代类型参数, 并将可迭代类型参数转换成set类型返回.</p><pre class="line-numbers language-none"><code class="language-none">In [166]: set()Out[166]: set()In [167]: set([1,2,3])Out[167]: {1, 2, 3}In [168]: set(range(10))Out[168]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>setattr(object, name, value): 接受三个必选参数, 将object.name属性赋值为value.</p><pre class="line-numbers language-none"><code class="language-none">In [172]: class a: passIn [173]: a1 = a()In [174]: setattr(a1, "b", 1)In [175]: a1.bOut[175]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slice(start,stop[,step]):返回表示由指定的索引集的切片对象, 该对象为只读数据属性.</p><pre class="line-numbers language-none"><code class="language-none">In [178]: slice(0, 1)Out[178]: slice(0, 1, None)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>sorted(iterable,*,key=None,reverse=False):将_iterable_对象排序后返回.</p><pre class="line-numbers language-none"><code class="language-none">key: 可选关键字参数,_key_指定一个参数的函数，该函数用于从_iterable中的_每个元素中提取比较键reverse: 可选关键字参数, 如果设置为True，则列表元素将按照每个比较相反的方式进行排序.In [181]: sorted(["12", "1", "34", "6", "90"], key=int)Out[181]: ['1', '6', '12', '34', '90']In [182]: sorted(["12", "1", "34", "6", "90"], key=int, reverse=True)Out[182]: ['90', '34', '12', '6', '1']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@staticmethod: 装饰器函数, 作用于类方法上, 将方法转换成静态方法.</p><pre class="line-numbers language-none"><code class="language-none">In [185]: class a:...:     @staticmethod...:     def b(x):...:         return xIn [186]: a.b(1)Out[186]: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>str(object=b’’,encoding=’utf-8’,errors=’strict’):返回一个字符串类型的对象,如果object是一个自定义对象, 那么首先会调用对象的__str__方法, 如果没有实现__str__方法则调用__repr__方法.</p><pre class="line-numbers language-none"><code class="language-none">In [194]: class a:...:     def __repr__(self): return "re"...:     def __str__(self): return "str"In [195]: str(a())Out[195]: 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sum(iterable[,start]):如果没有传入_start_参数, 则将_iterable_所有的元素叠加后返回, 如果传入了_start_参数,则从_start_参数开始将_iterable_的元素从左至右的叠加.</p><pre class="line-numbers language-none"><code class="language-none">In [201]: sum([1,2,3], 8)Out[201]: 14In [207]: sum(range(1, 101))Out[207]: 5050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>super([type[,object-or-type]]):该函数用于调用父类(超类)的一个方法.</p><pre class="line-numbers language-none"><code class="language-none">In [209]: class a:...:     def add(self, x):...:         return x + 1In [210]: class b(a):...:     def add(self, x):...:         return super().add(x)In [211]: b().add(1)Out[212]: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tuple([iterable]):返回一个元组对象, 接受一个可选的可迭代参数, 如果传入了该参数则将该参数转换成元组对象.</p><pre class="line-numbers language-none"><code class="language-none">In [214]: tuple([1,2,3,4])Out[214]: (1, 2, 3, 4)In [215]: tuple()Out[215]: ()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>type(name,bases,dict):只传入一个参数时将返回该参数的类型,使用三个参数，返回一个新类型对象,name则成为类对象的名称,base则表明了其父类, 可选的关键字参数则将成为类的属性.(type是类型实例关系的顶端, object是父子关系的顶端，所有的数据类型的父类都是它, Object是type的一个实例,Type是object的子类, 详细见type和object之间的关系)</p><pre class="line-numbers language-none"><code class="language-none">In [222]: d = type("objects", (), {"names": "this is name"})In [223]: dOut[223]: __main__.objectsIn [224]: d.namesOut[224]: 'this is name'In [217]: type(1)Out[217]: int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vars([object]):返回模块、类、实例、其他对象的__dict__属性.</p><pre class="line-numbers language-none"><code class="language-none">In [232]: class a:...:     x = 1In [233]: vars(a)Out[233]:mappingproxy({'__module__': '__main__','x': 1,'__dict__': &lt;attribute '__dict__' of 'a' objects&gt;,'__weakref__': &lt;attribute '__weakref__' of 'a' objects&gt;,'__doc__': None})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zip(*iterables):将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表,如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同.</p><pre class="line-numbers language-none"><code class="language-none">In [237]: zip([1,2,3,4], ["q", "w", "e", "r"])Out[237]: &lt;zip at 0x2aec3ad6d88&gt;In [238]: list(zip([1,2,3,4], ["q", "w", "e", "r"]))Out[238]: [(1, 'q'), (2, 'w'), (3, 'e'), (4, 'r')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>import(name,globals=None,locals=None,fromlist=(),level=0):import 语句将会调用该函数,该函数导入模块_name_, 使用给定的_globals和_locals来确定如何解释包上下文中的名称.</p><pre class="line-numbers language-none"><code class="language-none">In [240]: __import__("requests")Out[240]: &lt;module 'requests' from 'd:\\anaconda3\\envs\\python3\\lib\\site-packages\\requests\\__init__.py'&gt;In [241]: requests = __import__("requests")In [242]: requests.__version__Out[242]: '2.21.0'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aiohttp,asyncio,RunTimeError</title>
      <link href="//post/aiohttp-asyncio-runtimeerror.html"/>
      <url>//post/aiohttp-asyncio-runtimeerror.html</url>
      
        <content type="html"><![CDATA[<p>Firstly, you may have encountered the AssertionError: There is no current event loop in thread ‘Thread-1’. This is because each thread in an asyncio program has its own event loop, but only the main thread will automatically create an event loop. Therefore, if you call asyncio.get_event_loop() in a sub-thread, you will encounter this error.</p><p>To solve this problem, you need to explicitly create and set an event loop when starting the thread. Sample code is as follows:</p><pre class="line-numbers language-none"><code class="language-none">loop = asyncio.new_event_loop()asyncio.set_event_loop(loop)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Once you do this, you should be able to use get_event_loop() to work properly in a specific thread.</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--dict的优点以及缺点</title>
      <link href="//post/liu-chang-de-python-dict-de-you-dian-yi-ji-que-dian.html"/>
      <url>//post/liu-chang-de-python-dict-de-you-dian-yi-ji-que-dian.html</url>
      
        <content type="html"><![CDATA[<p>以下是Python中字典的一些特点：</p><ol><li>健必须是可散列的。这意味着键必须支持hash()函数，并且通过hash()方法得到的散列值是不变的。此外，它们还必须支持eq()方法以检测相等性。如果a == b，则hash(a) == hash(b)。</li><li>字典内存开销大。由于字典是由散列表实现的，散列表中可能会有一些稀疏性，这会占用一些空间。与字典的速度相比，这些内存消耗可以忽略不计。</li><li>字典的键顺序不是唯一的。由于散列表在插入或读取时可能会产生散列冲突，因此字典中键的顺序不是唯一的。但是，不管字典键的顺序如何变化，如果两个字典键值对都相同，则这两个字典是相等的。</li></ol><pre class="line-numbers language-none"><code class="language-none">a = {    "1": 1,    "2": 3,    "3": 4,    "4": 4}b = {    "3": 3,    "4": 4,    "1": 1,    "2": 2}a == bTrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash tables in Python dictionaries</title>
      <link href="//post/liu-chang-de-python-zi-dian-zhong-de-san-lie-biao.html"/>
      <url>//post/liu-chang-de-python-zi-dian-zhong-de-san-lie-biao.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>Dictionaries in Python use hash tables, which are actually sparse arrays, meaning that some elements are empty. When constructing a dictionary, two table elements are used, one to mark the keys and the other to mark the values. Because the lengths of the two table elements are equal, the dictionary can be searched by the offset of the table elements.</p><p>In Python, the most efficient built-in data types are dictionaries and sets, both of which are implemented through hash tables. To test the speed of different data types in Python, I conducted the following experiment:</p><pre class="line-numbers language-none"><code class="language-none">import timeMAX = 10000000list_a = [i for i in range(MAX)]set_a = set(list_a)dict_a = {}.fromkeys(list_a)test = [i for i in range(1000)]def testTime(x,name):    start = time.clock()    for i in test:        if i in x:            pass    print(name,':','%f' % (time.clock() - start))testTime(list_a, 'list')testTime(set_a, 'set')testTime(dict_a, 'dict')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The results are as follows:</p><pre class="line-numbers language-none"><code class="language-none">list : 0.012472set : 0.000079dict : 0.000071<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>From the above, it can be seen that sets and dictionaries are much faster than other types. This is because lists do not support the <code>in</code> operator with hash tables.</p><p>The hash algorithm works as follows: for example, if Python wants to obtain the value behind <code>dict[key]</code>, it first uses <code>hash(key)</code> to calculate the hash value of the key, and then takes the lowest few digits of the hash value as the offset of the table element. If the table element is empty, a <code>KeyError</code> exception will be thrown; if found, a <code>key:value</code> value will be obtained, and Python will compare the hash values of the two keys. If they are identical, the value is returned, and if they are not equal, it is called a hash collision. This occurs because the hash table maps random elements to a few digits, and the hash table needs to rely on this number for retrieval. To solve this problem, the hash table will take a few more digits and search the table elements. If the table element is empty, a <code>KeyError</code> exception will be thrown; if not found, the above steps will be repeated until found.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python--特殊方法</title>
      <link href="//post/liu-chang-de-python-te-shu-fang-fa.html"/>
      <url>//post/liu-chang-de-python-te-shu-fang-fa.html</url>
      
        <content type="html"><![CDATA[<p>Python中的特殊方法主要是被Python解释器调用，大部分情况下不需要自己实现特殊方法，比如<code>len(x)</code>，实际上是调用了<code>len()</code>方法。在实际编程中，我们不会使用<code>x.len()</code>这样的写法。如果<code>x</code>是一个自己实现的类并且在类里面实现了一个<code>len()</code>方法，那么Python就会调用这个类里面的方法。</p><p>大部分情况下，调用特殊方法都是隐式调用。例如：<code>for i in x:</code>，实际上是调用了<code>x</code>的<code>iter()</code>方法。所有的特殊方法都可以自定义，但在编程时不建议大量实现特殊方法，除非进行元编程。</p><p>因此，在自定义类时应该遵循Python的惯例，尽可能使用Python内置的方法和函数，而不是过度实现特殊方法。这样可以提高代码可读性和可维护性。同时，合理地实现特殊方法也是元编程的一种方式，可以实现更高级的功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python根据exif信息旋转图片</title>
      <link href="//post/python-gen-ju-exif-xin-xi-xuan-zhuan-tu-pian.html"/>
      <url>//post/python-gen-ju-exif-xin-xi-xuan-zhuan-tu-pian.html</url>
      
        <content type="html"><![CDATA[<p>最近写业务代码时遇到了一个需求：压缩图片。这本应该是一个简单的需求，三下五除二就能解决。但是当我用手机上传图片时，发现压缩后的图片都歪了。经过查找，发现问题出在图片的exif信息中的Orientation记录，它记录了图片的旋转角度。因此，需要根据这个角度来旋转图片。</p><p>首先需要读取图片的exif信息，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">from PIL import Imageimg = Image.open('1.jpg')# 先判断图片是否有exif信息if hasattr(img, '_getexif'):    # 获取exif信息    dict_exif = img._getexif()    if dict_exif.get(274, 0) == 3:        # 旋转        new_img = img.rotate(-90)    elif dict_exif.get(274, 0) == 6:        # 旋转        new_img = img.rotate(180)    else:        new_img = imgelse:    new_img = imgnew_img.save('new_1.jpg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个代码，我们可以获取图片的exif信息，并根据其中的Orientation记录来旋转图片。最终，我们得到了正确的压缩后的图片。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Usage of Python -- namedtuple</title>
      <link href="//post/python-de-gao-ji-yong-fa-namedtuple.html"/>
      <url>//post/python-de-gao-ji-yong-fa-namedtuple.html</url>
      
        <content type="html"><![CDATA[<p>The <code>namedtuple</code> function can be used to create a named tuple or class, which can be more effective for debugging code. Here’s an example:</p><pre class="line-numbers language-none"><code class="language-none">from collections import namedtuple# Create a classa = namedtuple('c', ('name', 'age'))x = a('perror', 21)# Access via object methodprint(x.name)print(x.age)# Access via indexingprint(x[0])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In addition to inheriting methods from normal tuples, named tuples have three additional methods: the <code>_fields</code> class attribute, <code>make()</code> class method, and <code>_asdict()</code> class instance method.</p><p>Here’s how to use these methods:</p><pre class="line-numbers language-none"><code class="language-none"># View all fields in the named tupleprint(x._fields)# `_make` generates a class instance using an iterable objects = ('perror', '21')new_s = x._make(s)# Print the tuple's fields in a more friendly format using the class instance methodprint(new_s._asdict())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Note that after the named tuple is created, its elements can be accessed either by attribute name or by indexing.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
