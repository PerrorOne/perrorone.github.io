---
title: python深拷贝浅拷贝
date: 2023-02-18 17:46:25
top: true
tags:
    - python
---
关于Python中的对象拷贝问题，我们需要了解is和==的区别:

```
>>> a = [1,2,3,4]
>>> b = [1,2,3,4]
>>> a == b
True
>>> a is b
False

```

从上面的例子中可以看出，a和b中的值是相等的，但是is的结果却不一样。这是因为Python比较的是a和b的值是否相等，而is比较的是对象的标识是否相等。因此，在Python中我们通常使用==来比较对象的值是否相等，使用is来判断对象绑定的值是否为None。需要注意的是，有一些初学者经常犯的错误是使用None来比较一个字符串、列表或字典是否为空，这是不正确的，因为这些变量无论从对象标识还是数值上都与None不相等。

在Python中，我们通常使用浅拷贝来复制对象。copy模块为我们提供了copy（浅拷贝）和deepcopy（深拷贝）函数。

浅拷贝指的是将拷贝的对象引用拷贝一份，拷贝对象指向的是被拷贝对象的值。换句话说，在原有值的基础上再添加了一份引用。

```
>>> a = 1
>>> b = a
>>> id(a)
4297636352
>>> id(b)
4297636352

```

深拷贝指的是将拷贝对象的值复制一份，并新建一个对象，这个新的对象的值和对象标识都与被拷贝对象相等。

```
>>> import copy
>>> a = [1,2,3]
>>> b = copy.deepcopy(a)
>>> b
[1,2,3]
>>> a
[1,2,3]
>>> a == b
True
>>> a is b
True
>>> id(a)
4297636352
>>> id(b)
4297636352
>>> a.append(0)
>>> a
[1,2,3,0]
>>> b
[1,2,3]
>>> b.append(9)
>>> b
[1, 2, 3, 9]
>>> a
[1, 2, 3, 0]

```

基于这种现象，我们应该特别注意函数在使用可变参数作为默认参数时，如果不注意就会出现下面这种情况:

```
>>> def a(x = []):
...     x.append(0)
...     print(x)
>>> a()
[0]
>>> a()
[0, 0]
>>> a()
[0, 0, 0]

```

为了避免这种情况，我们应该避免使用可变对象作为函数默认参数:

```
>>> def a(x = None):
...     if x is None:
...         x = []
...     else:
...         x.append(0)
...     print(x)
...
>>> a()
[]
>>> a()
[]

```

同时，在创建类初始化传参时也使用了浅拷贝来传递参数，这会导致下面这种情况：

```
>>> class A:
...     def __init__(self, name):
...         self.name = name
...     def printf(self):
...         print(self.name)
...
>>> x = [1,2,3,4]
>>> a = A(x)
>>> a.printf()
[1, 2, 3, 4]
>>> x.append(5)
>>> a.printf()
[1, 2, 3, 4, 5]

```

当传入的参数发生改变时，类里面的变量的值也会随之改变，这种情况很难发现。深拷贝和浅拷贝的最大区别在于：深拷贝会拷贝父级对象及其子对象，而浅拷贝只拷贝父级对象。
